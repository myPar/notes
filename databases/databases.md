### Основные понятия
__Данные__ - совокупность сведений, зафиксированных на определённом носителе информации в форме, пригодной для хранения, передачи и обработки.  

__Информация__ - результат преобразования и анализа данных.  

Таким образом ___данные___ являются фиксированными сведениями, а ___информация___, это результат анализа и обработки этих сведений.  

__Предметная область__ - часть реального мира, для которой создаётся информационная система.  

__База данных__ - [упорядоченный набор структурированной информации или данных (Oracle)](https://www.oracle.com/database/what-is-database/).  

__Система управления базами данных (СУБД)__ - Набор программ, обеспечивающий средства создания и манипулирования базой данных на ЭВМ.  

__Система базы данных__ - ___СУБД___ + данные. Иногда в систему базы данных включают и приложения.  

__Сущность__ - информационный объект, моделирующий объекты приложения.  

__DDL__ - Data definition language. Язык для описания структуры базы данных.  

__DML__ - Data manipulation language. Язык для манипулирования данными (вставка, изменение, удаление)  

__QL__ - Query language. Язык запросов к данным.  

__Транзакция__ - набор операций выполняющийся _атомарно_, т.е. либо выполняется полностью, либо не выполняется вовсе.  

__Целостность базы данных__ - соответствие имеющейся в БД информации её внутренней логике, структуре, и всем явно заданным правилам. Каждое правило, налагающее некоторое ограничение на БД, называется ___ограничением целостности___ ([wiki](https://ru.wikipedia.org/wiki/%D0%A6%D0%B5%D0%BB%D0%BE%D1%81%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C_%D0%B1%D0%B0%D0%B7%D1%8B_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)).

### Предпосылки использование баз данных

Задачей является создать автоматизированную информационную систему. Которая в своей работе подразумевает взаимодействие с некоторым набором данных - его анализ, сохранение и редактирование.  

Для решения данной задачи необходимо:  
* Создание модели предметной области. Т.е. выделение сущностей и их взаимосвязей. Данные о сущностях будут помещаться в информационную систему.

* Создание системы хранения данных (базу данных). Стуруктуру, для которой можно обеспечить хранение и взаимодействие с данными.

* Обеспечение доступа к данным. Требуется реализовать язык взаимодействия с данными в системе хранения. Язык должен обеспечивать:
    * Помещение данных в систему хранения.
    * Извлечение данных из системы хранения.
    * редактирование и удаление данных.

### Этапы разработки базы данных

##### Проектирование
* Логическое (семантическое) проектирование
    * выделение сущностей предметной области и описание информации, подлежащей моделированию.
    * разработка семантической модели предметной области без привязки к СУБД. Иными словами проектирование семантических связей между сущностями.
    * преобразование семантической модели в модель данных конкретной СУБД. Зачастую в реляционную модель.
* Физическое проектирование - процесс определения организации хранения данных и характеристик доступа к данным (по времени, по расходу памяти и т.д.) для обеспечения целостности, безопасности и производительности БД.
    * определение организации хранения данных
    * определение меры целостности и безопасности
    * определение производительности

##### Планирование
* Планирование аппаратных средств
* Планирование програмных средств

##### Реализация

Собственно, реализация базы данных на конкретной СУБД.

##### Сопровождение

Исправление ошибок работы готовой базы данных.

##### Реинжиниринг

Изменения в текущей реализации -добавление дополнительного функционала и т.д.

### Семантическое моделирование

__Модель Сущность-Связь (ER-model)__ - включает в себя выделение ___сущностей___, их ___атрибутов___ и ___связей___ между ними.

##### Этапы проектирования __ER-модели__:
* Выделение сущностей
    * определение их атрибутов (свойств сущностей)
    * выделение идентифицирующих атрибутов (ключей)
* Определение связей
    * их типов (one-one, one-many, many-many)
    * их обязательности
* Отображение модели в виде __ER-диаграммы__.

* Объединение представлений пользователей (моделирование локальных представлений)
    * _локальное представление_ соответствует отдельному приложению, пользователю или задаче. Для создания полной картины представления модели эти локальные представления требуется объединить. Происходит это посредством применения операций __агрегации__, __идентичности__ и __обобщения__ к локальным представлениям.

###### связанные определения:
* __Идентичность__ - две сущности идентичны, если имеют одинаковое семантическое значение.
* __Агрегация__ - декартово произведение сущностей. Проще говоря, объединение нескольких сущностей в одну.
* __Обобщение__ - обобщение нескольких мн-в сущностей в одно. (Хонда, Тойота - автомобили)

##### Типы связей
* __many-one__ - если каждый член мн-ва __A__ посредством связи __R__ может быть соединён не более, чем с одним членом мн-ва __B__ , тогда __R__ - это связь типа many-one.
    _пример_: сотрудник может работь в единственном отделе (связь many-one)
* __one-one__ - если связь __R__ является __many-one__ в обоих направлениях, то тогда это связь типа __one-one__.
    _пример_: страна и президент; сетевое устройство и его mac-адрес

* __many-many__ - если связь __R__ ни в одном из направлений не относится к типу __many-one__, то это связь __many-many__

##### Нотации ER-диаграмм
* Нотация Чена - мн-ва сущностей обозначаются прямоугольниками, отношений - ромбами. Если сущность участвует в отношении, они связаны линией. Если отношение не является обязательным, то линия пунктирная. Атрибуты обозначаются овалами и связываются линией с одним отношением или с одной сущностью.

* "Вороньи лапки" - мн-ва сущностей обозначается прямоугольниками; отношение обозначается линией, его степень указывается наличием/отсутствием вилки на конце, необязательность связи указывается кружком на конце; атрибуты сущностей записываются внутри прямоугольников.

### Архитектура системы баз данных

СУБД должна обеспечивать следующие функции:
* Позволять пользователям создавать новые базы данных и определять их схемы с помощью __DDL (Data definition language)__.
* Позволять пользователям писать запросы к базе данных на ___языке запросов (Query language)___ или на __языке управления данными (Data management language)__.
* Позволять хранить большие объёмы данных на протяжении длительного времени.
* Предотвращать опасность несанкционированного доступа к данным.
* Обеспечивать эффективность операций просмотра и изменения данных.
* Обеспечение корректного параллельного взаимодействия с базой данных. Исключение влияния действий одного пользователя на действия другого.

Таким образом, можно выделить следующие ___типовые функции___ СУБД:
* Определение типов данных, структур данных, ограничений по значениям.
* Создание или загрузка начального содержимого базы данных.
* Манипулирование базой данных
    * Извлечение данных - поиск данных по запросам.
    * Модификация данных - втавка, удаление, обновление содержимого БД

* Управление многопользовательским доступом
* Управление внешней памятью
* Управление целостностью данных (физической и семантической)
* Управление защитой от несанкционированного доступа к базе данных

### Структура СУБД

<a href="https://ibb.co/nB1QcfW"><img src="https://i.ibb.co/vhdLPmt/DMSscema.jpg" alt="DMSscema" border="0"></a>

##### Компилятор запросов
Трансляция запроса во внутреннее представлние - план запроса. Компоненты:
* лексический анализатор - преобразование запроса в древовидную структуру.
* препроцессор запросов - семантический анализ древовидного представления, преобразование древовидного представления в дерево алгебраический операций.
* оптимизатор запросов - преобразование запроса в наиболее эффективную пос-ть фактических операций над данными.

##### Компилятор DDL

Команды DDL обрабатываются лексическим анализатором и передаются исполняющей машине, которая, используя менеджер ресурсов, изменяет метаданные (информацию, описывающую структуру базы данных).

##### Исполняющая машина
Выполнение операций запроса (интерпретатор).

##### Менджер буферов

Разбиение оперативной памяти на буферы - участки-страницы, куда помещается содержимое дисковых блоков.

* _Примечание:_ все компоненты СУБД обращаются к данным через буфера, менеджер буферов или через исполняющую машину.

* _Примечание:_ категории данных:
    * Фактические данные - содержимое БД.
    * Метаданные - описание семантической структуры БД (схема базы данных).
    Через метаданные СУБД обеспечивает доступ приложения к базе данных.
    * Статистика - информация о свойствах данных (размер отношения, сведения о значениях в колонках и т.д.)
    * Индексы - структуры, повышающие скорость доступа к данным.

##### Менеджер транзакций
Реализация выполнения __транзакций__. Транзакции должны выполняться _атомарно_, _изолированно_ друг от друга, сохраняя _целостность_ БД, обладать св-м _устойчивости_; т.е. с соблюдением принципов [ACID](https://ru.wikipedia.org/wiki/ACID). 

Менеджер транзакций имеет вложенные компоненты - __планировщик__ и __менеджер протоколирования__. Менеджер транзакций также решает проблему взаимных блокировок.
* _Примечание:_ транзакциями являются команды DML, поскольку только они модифицируют данные в БД. Команды QL только получают данные из БД.
##### Менеджер протоколирования
Для обеспечения ___надёжности___ (Durability) транзакций каждое изменение в БД фиксируется в специальном системном журнале (файлах) в виде так называемого _протокола изменений_.  

Информация _протокола_ с начала сохраняется в буферах, затем менеджер протоколирования, взаимодействую с менеджером буферов переодически сбрасывает данные на диск. Таким образом, имеется возможность восстановить необходимое состояние БД в случае сбоев.  

##### Менеджер восстановления

Считывает протоколы изменений и, в случае необходимости, приводит БД в некоторое целостное состояние.  

##### Менеджер хранения данных

Управляет размещением данных на дисках и реализует обмен данных между диском и оперативной памятью.  

##### Планировщик заданий

Транзакции обязаны выполняться в строгой изоляции друг от друга. Поскольку в системе может исполняться несколько процессов транзакций одновременно, то требуется обеспечить корректный конкурентный доступ к разделяемым ресурсам БД.  

Планировщик заданий устанавливает блокировки на соответсвующие фрагменты БД, которые препятствуют одновременному изменению данных несколькими транзакциями. Данные блокировок (примитивов синхронизации) храняться в таблице блокировок.  

Планировщик заданий воздействует на процесс выполнения
запросов и других операций, регулируя доступ виртуальной машины к разделяемым данным.  

Также, планировщик заданий решает проблему взаимных блокировок.  

##### Подход баз данных

* __Абстракция данных__
    Модель данных скрывает детали реализации БД и предоставляет пользователю концептуальный уровень взаимодействия с ней. Программы обращаются к модели данных, а не к конкретной области памяти на диске.
<br>

* __Многоаспектный взгляд на данные__

    Каждый пользователь может работать только с теми данными в БД, которые его интересуют.
<br>

* __Независимость данных от программ__

    Данный подход предполагает, что при изменении данных приложения во внешней памяти, исходный код приложения менять будет не нужно. Однака, будет требоваться перекомпиляция.  

    Независимость данных от приложения можно выделить на __физическом__ и __логическом__ уровнях.  

    * Физический - приложению не важно представление данных и методы доступа к ним на физическом уровне. (последовательное хранение, индексное, B-дерево)
    * Логический - изменение логической структуры БД не влияет на работу приложения. (изменение состава полей в таблице, изменение тпов данных)  
<br>

* __Множественный доступ к данным__
    Поддерживается одновременный доступ нескольких пользователей к базе данных. Изменение, добавление, извлечение данных.  
    
    Управление одновременным доступом гарантирует, что любая транзакция либо успешно завершиться, либо завершиться без изменения БД (будет сохранена целостность). Данные после всех успешно завершённых транзакций будут сохранены в БД.  

    СУБД может поддерживать [OLTP](https://ru.wikipedia.org/wiki/OLTP), которая позволяет СУБД обрабатывать большое кол-во транзакций в единицу времени.

##### Преимущества СУБД

* Управление избыточностью данных
    * устранение избыточности информативных (пользовательских) данных - аномальные вставки, редактирование, удаление.
    * Управляемая избыточность - индексирование, репликации __?__
* Обеспечение целостности данных
    * Логичиская целостность - обеспечивается на уровне описания данных, при помощи DDL.
    * Физическая целостность - СУБД предоставляет механизмы восстановления целостного состояния физических данных - backup, recovery. __?__
* Обеспечение независимости данных - модель представления данных отделена от физической модели хранения. Пользователь работает только с моделью представления.

* Обеспечение корректного множественного доступа к данным - СУБД обеспечивает корректное выполнение одновременных запросов несколькими пользователями.

* Обеспечение безопасности данных - СУБД имеет средства ограничения доступа к данным. Например, при помощи авторизации в конкретной БД.

* Действия над данными при помощи дедуктивных и активных правил __?__

* Обеспечение соблюдения стандартов - благодаря средствам логического описания данных в СУБД очень просто регламентировать стандарты модели данных.

* Сокращение времени разработки приложений - поскольку модель данных приложения и их физическое хранение реализуется СУБД, программистам, легко поддержать вз-ие с данными в приложении и уделять время непосредственно реализации логики приложения.

* Гибкость при изменении структуры базы данных - структура БД может модифицироваться под новые требования без серьёзных изменений внутри реализации приложения, да и в самой БД тоже.

* Доступность текущего состояния информации - благодаря грамотному баллансу реализации кэширования и дискового хранения данных, СУБД предоставляет эффективный доступ к БД в любой момент времени. Примерами могут являться онлайн приложения.

### Реляционное исчисление

__определения:__
* __отношение__ - конечное подмн-во декартового произведения.
    $D_1, ..., D_n - мн-ва \hspace{2mm}(домены)$ $Декартово \hspace{1mm} произведение \hspace{1mm} этих \hspace{1mm} мн-в - D_1\times ... \times D_n = \{(v_1, v_2, ..., v_n) | v_i \in D_i \forall i = 1..n\}$

* __схема отношения__ - запись вида - $R(A_1:D_1, ..., A_k:D_n) \hspace{1mm} k \geq n$
$R$ - имя отношения
$A_i$ - имена атрибутов
$D_j$ - имена доменов

Все атрибуты в $A_i$ в схеме отношения различны. Домены, которые являются оластью определения значений различных атрибутов, могут совпадать.

* __степень отношения__ - число атрибутов в отношении.

* __кардинальное число__ - число кортежей в отношении. Мощность отношения.
* __ключ отношения__ - атрибут, или мн-во атрибутов однозначно определяющее кортеж отношения. Очевидно, что ключ у отношения всегда существует, поскольку одним из них всегда будет являться мн-во всех атрибутов.

__Неформальные определения__

Для упрощения понимания того, как все эти определения относятся к табличным данным, с которыми мы будем работать, можно считать, что неформально __отношение__ - это двумерная таблица, строками в которой являются элементы декартового произведения. В формальном определении модели данных строками являются __кортежи__ значнений.

Каждый столбец такой таблицы соответствует значениям некоторого атрибута для каждой строки соответственно. Каждый столбец имеет заголовок соответствующей описанию того, какого типа элементы лежат в нём. В формальном определении заголовок соответствует __имени__ атрибута.

__Пример__

|имя|номер пропуска|возраст|зарплата|
|---|---|---|---|
|Сергей|021|24|70000|
|Андрей|340|32|120000|
|Пётр|190|40|200000|
|Павел|647|27|75000|
|Владислав|003|21|40000|

Данная таблица является примером __отношения__ под названием _сотрудники_, __атрибутами__ которого являются _имя_, _номер пропуска_, _возраст_ и _зарплата_ сотрудника соответственно. Таким образом, __схема__ такого отношения будет выглядеть слудующим образом: Сотрудники(_имя_, _номер пропуска_, _возраст_, _зарплата_).

__Степень__ этого отношения равна 4 (по числу атрибутов) и __кардинальное число__ равно 5 (по числу кортежей).

__Фундаментальные св-ва отношений__

* отсутствие кортежей дубикатов

* отсутствие упорядоченности кортежей

* отстствие упорядоченности атрибутов

* атомарность значений атрибутов

__Домены__

Как было указано в определении _схемы отношения_, доменами является области определения значений соответствующих атрбутов отношения. Исходя из этого можно дать техническое определение этой концепции:

Домен задаётся базовым типом данных и логическим выражением, определяющим возможные значения атрибута, соответствующего этому домену. Отличным примером являются средства DDL, когда мы определяем атрибут таблицы задавая его тип и необходимые ограничения на значения (CONSTRAINTS).

#### Реляционная модель данных

Реляционная модель данных (РМД) представляет из себя логическую модель данных, реализующую следующие аспекты:

* структурный аспект - данные представляют из себя набор отношений.

* аспект целостности - отношения соответсвуют определённым условиям целостности.

* аспект манипулирования - РМД поддерживает средства манипулирования отношениями (реляционная алгебра, реляционое исисление).  

__Реляционная алгебра__

Реляционной алгеброй является замкнутая система операций над отношениями в реляционной модели данных. Замкнутость означает, что применение операций к отношениям в результате также даст отношение.  

Основное применение реляционной алгебры - предоставление теоретической основы для реляционных баз данных. В частности для теоретического обоснования корректности и полноты языка запросов __SQL__.

__объединение__, __пересечение__, __разность__

Стандартные операции из теории мн-в. Условия их выполнения - это одинаковые _схемы отношений_, т.е. атрибуты - одинаковые и определены на одних и тех же доменах.

__примеры:__
схемы отношений - $R_1(A:INT, B:STRING(10), C:FLOAT) \hspace{1.5mm} S_1(A:INT, B:STRING(10), C:FLOAT)$

$R_1=\{(6, Sergey, 0.5), (1, Pavel, 1.01)\}$
$S_1=\{(1, Andrey, 9.4), (1, Pavel, 1.01)\}$

$R_1 \cup S_1 = \{(6, Sergey, 0.5), (1, Pavel, 1.01), (1, Andrey, 9.4)\}$
$R_1 \cap S_1 = \{(1, Pavel, 1.01)\}$
$R_1 - S_1 = \{(6, Sergey, 0.5)\}$

__декартово произведение__

Тоже самое, стнадартное определение из теории мн-в. Ограничений на схему отношений нет: 
$R(A,B,C) \times S(E,D) = T(A,B,C,E,D)$
$R(\bold{A},B,C) \times S(\bold{A},D) = T(A_1,B,C,A_2,D)$

_Степень_ результирующего отношения будет равна сумме степеней исходных. _Кардинальное число_ - произведению кардинальных чисел исходных отношений.

__примеры:__

$R(\bold{A},B,C) = \{(1,2,3), (2,2,2), (3,4,5)\} \hspace{1.5mm} S(\bold{A},D) = \{(2,3), (1,1)\}$

$R(\bold{A},B,C) \times S(\bold{A},D) = \{(1,2,3, 2, 3), (1,2,3,1,1), \\
\hspace{40mm}                             (2,2,2,2,3), (2,2,2,1,1), \\
\hspace{40mm}                             (3,4,5,2,3), (3,4,5,1,1)\}$

__специальные операции__

* __Селекция__ - операция $\sigma_f(R(A_1, ..., R_k))$ на отношением $R$, порождающее отношение $R_1(A_1, ..., R_k)$ такое, что:
    1. $R_1 \subseteq R$ - $R1$ является подмножеством исходного отношения.
    2. Кортежи $R_1$ удовлетворяют логической ф-ции $f$, которая строится из:
        * операндов - атрибуты отношения и константы
        * операторов сравнения 
        * логические операторы: _and_, _or_, _not_
        * скобок (для указания приоритета операций)

Можно провести аналогию с оператором __SQL__ SELECT: SELECT FROM $R$ WHERE $f$

* __Проекция__ - операция $\rho_{A_{i1},..A_{i_k}}(R)$ где $R=R(A_1, ..., A_n)$ отношение, порождающая новое отношение $R_1$ с атрибутами $A_{i1},..A_{i_k}$ из отношения $R$, где $A_{i1},..A_{i_k} \subset A_1,..,A_n$. Отношение $R_1$ порождается следующим образом:

    1. Каждый кортеж $R_1$ получается из кортежа отношения $R$ путём удаления значений атрибутов не отмеченных в $A_{i1},..A_{i_k}$.
    2. Из полученного набора  кортежей удаляются дубликаты.
<br/>

* __Соединение__

    У данной операции имеется множество вариантов:
    * __Эквисоединение__ - пусть имеется два отношения $R$ и $S$, которые не имеют одинаковых атрибутов, тогда _эквисоединением_ этих двух отношений будет являться селекция по логической ф-ции __f__ от декартового произведения этих отношений: $\sigma_f(R \times S)$.
    
    * __Натуральное соединение__ - или _Natural/Inner JOIN_. Определено для отношений $R$ и $S$, имеющих одинаковые атрибуты. Натуральным соединением двух таких отношений будет отношение, полученное в результате проекции на объединённое мн-во атрибутов $R$ и $S$ от результата селекции декартового произведения $R$ и $S$ по логической ф-ции __f__, где __f__ имеет следующий вид: $f = A_{r_1}=A_{s_1} \& A_{r_2}=A_{s_2} \& .. \& A_{r_n}=A_{s_n}$ где $A_{r_i}=A_{s_i}$ - одинаковые атрибуты ил $R$ и $S$ соответственно (получается, что логическая ф-ция берётся по равенству значений всех идентичных атрибутов в $R$ и $S$): $\bold{R} \hspace{1mm} JOIN \hspace{1mm} \bold{S} \hspace{1mm} ON \hspace{1mm} \bold{f} = \pi_{attr(R) \cup attr(S)}(\sigma(\bold{R} \times \bold{S}))$. Стоит отметить, что в SQL JOIN можно выполнять и по одному одинаковому атрибуту в двух отношениях, а в реляционной алгебре он делается по всем.  
    
    * __Left Outer Join__ - отличается от операции натурального соединения тем, что в результирующем отношении присутствуют все строки из _левого_ отношения (в данном случае отношения $R$) а те строки из правого отношения, для которых истинность ф-ции __f__ не выполняются заполняюся значениями NULL.  

    * __Right Outer Join__ - аналогично предыдущему, только уже для правого отношения (в данном случае для отношения $S$).  

    * __Full Outer Join__ - здесь же, в результирующее отношение входят все строки как из первого, так и из второго отношения. Если для какой-то строки из $R$ или $S$ не выполняется истинность ф-ции __f__, то она заполняется значениями NULL.  
<br/>

* __Деление__ - пусть даны два отношения $R$ с мн-м атрибутов $X \cup Y$ и $S$ с мн-м атрибутов $Y$.  Результатом _деления_ отношения $R$ на $S$ будет максимальное по включению отношение $C$ с мн-м атрибутов $X$ такое, что $S \times C \subseteq R$


__Достоинства реляционной модели__

1. набор используемых абстракий относительно небольшой: отношение, кортеж, атрибут, домен, тип данных, ключ.
2. полностью математическая реализация операций.

__Недостатки реляционой модели__

1. Небольшой набор типов данных.
2. Небольшой набор средств манипулирования данными.

#### Теория проектирования реляционных баз данных

__аномалии__

* избыточность - содержание лишних данных в базе.
* включение - значение ключевого атрибута стало неопределённым (NULL).
* удаление - нарушение ссылочной целостности, когда элемент отношения, на который ссылались удалили.
* обновление - опять же, нарушение ссылочной целостности, когда элемент отношения на который ссылались обновился, и теперь требуется обновить данные в других таблицах.

__ограничения на отношения__
Для предотвращения возникновения подобных аномалий в реляционной модели данных предусмотрены ограничения целостности. Которые можно использовать, чтобы не позволять принимать кортежам отношений недопустимые значения.  

Существует два вида ограничений:

* семантические ограничения, зависящие от семантики элементов домена.
* ограничения, определённые в виде неравенства для значений атрибутов.

__функциональные зависимости__

Пусть $R(A_1, .., A_n)$ - отношение, $X,Y \subseteq {A_1, .., A_n}$ подмножества атрибутов этого отношения.  

$Y$ функционально зависит от $X$, если каждому кортежу значений атрибутов из $X$ соответствует ровно один кортеж значений атрибутов из $Y$.

Т.е. $ \forall r_1, r_2 \in R, \pi_x(r_1)=\pi_x(r_2) \implies \pi_y(r_1)=\pi_y(r_2) $

Ф-циональные зависимости обладают следующими математическими свойствами:

* __транзитивность__ - $A,B,C$ - мн-ва атрибутов отношения. Пусть $A \to B$ и $B \to С$, тогда $A \to C$.

Введём определения:
* __логическое следствие__ - пусть $F$ - мн-во функциональных зависимостей в отношении $R$, $X,Y \subseteq attr(R)$. Функциональная зависимость (ФЗ) $X \to Y$, ___логически следует___ из $F$, если для любого отношения со _схемой_ отношения $R$, на котором выполняются все зависимости из $F$, выполняется и $X \to Y$.

* __замыкание__ - $F^+$ замыкание $F$, мн-во ф-циональных зависимостей, которые следуют из $F$. 