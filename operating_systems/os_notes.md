# Операционная система UNIX System V Realise 4 (SVR4)
##### Лекционный материал по устройсту операционной системы UNIX (семейства UNIX-подобных операционных систем). Выделяется и описывается то общее, что они имеют, а именно: базовый пользовательский и программный интерфейсы, назначение основных компонент, их архитектура и взаимодействие.

### хронология UNIX System V
* __UNIX System V__ - была выпущена в 1983 году.  
* __System V Release 3 (SVR3)__ - появилась в 1987 году. В этой версии был добавлен ряд дополнительных возможностей:
     * Подсистему ввода/вывода, основанную на архитектуре STREAMS.
     * Переключатель файловой системы (File System Switch), обеспечивавший одновременную поддержку различных файловых систем.
     * Разделяемые(динамические) библиотеки. Библиотеки, которые могут использоваться несколькими приложениями одновременно на стадии исполнения.
     * Программный интерфейс сетевых приложений Transport Layer Interface (TLI).
* __System V Release 4 (SVR4)__ - Была выпущена в 1989 году. Объединяла возможности нескольких версий UNIX: SunOS, BSD UNIX, и предыдущие версии System V. Новые черты системы:
     * Командные интерпретаторы Korn dhell и С shell (BSD)
     * Систему терминального ввода/вывода, основанную на STREAMS (System V)  
     * Быстрая файловую систему FFS (BSD)
     * Сетевой программный интерфейс сокетов (BSD)
     * Отображение файлов в оперативную память (SunOS)
     * Поддержку диспетчеризации реального времени
Также многие компоненты системы были поддержаны стандартами ANSI и POSIX.

### Стандартизация UNIX

UNIX является первой действительно переносимой операционной системой. В свободно распространяемые версии UNIX постоянно вносили изменения, что порождало большое кол-во версий данной системы. И чем дальше, тем больше были различия между существующими версиями. Это вело к отсутствию канонического UNIX и, как следствия усложнению переносимости приложений, написанных под ту или иную версию.

Поэтому появилась необходимость описать стандарты системы. Их наличие обеспечило бы простоту переносимости приложений. В результате возникло несколько организаций по стандартизации, которыми был разработан ряд стандартов, повлиявших на дальнейшую разработку систем UNIX.

### POSIX

Стандарт POSIX (Portable Operating System Interface for Computer Environment) описывает набор услуг, предоставляемых системой приложениям (API), в частности стандартную библиотеку языка С. Тем самым, обеспечивается переносимость приложений на уровне исходного кода.
Опишем несколько значимых стандартов POSIX:
* POSIX 1003.1 - был разработан в 1988 году. Определял API.
* POSIX 1003.2 1992 - Включает определение командного интерпретатора UNIX и набора утилит.
* POSIX Содержит дополнения, относящиеся к поддержке приложений реального времени

* POSIX 1003.1c-1995 - Включает определения "нитей" (threads) POSIX, известных также как pthreads.


### Устройство операционной системы

##### Ядро системы
Ядро обеспечивает базовую функциональность операционной системы. Оно создаёт процессы, управляет ими, распределяет память и обеспечивает доступ к файлам и переферийным устройствам.

Взаимодействие прикладных приложений с ядром происходит через ___интерфейс системных вызовов___, который реализован в виде функций стандартной библиотеки языка C. Он представляет из себя набор услуг ядра, который могут использовать приложения.

Процесс, в котором исполняется приложение, запрашивает услугу ядра посредством ___системного вызова___. Ядро выполняет данный запрос от имени процесса и возвращает ему необходимые данные.  

<a href="https://ibb.co/SRKh8Lc"><img src="https://i.ibb.co/yW8w13p/image.jpg" alt="image" border="0"></a>

### Процесс

Процесом называется экземпляр исполняемой программы вместе с данными этой программы, а также набор атрибутов, хранящихся в ядре операционной системы.  

Каждый раз при запуске новой программы создаётся новый процесс в рамках которого данная программа исполняется.  

Одним из атрибутов процесса в UNIX является его идентификатор _pid_, который в данный момент времени является уникальным, но может быть переиспользован после завершения процесса.  

Также, в разные моменты времени процесс может исполнять разные программы. Сделать это можно при помощи системного вызова _exec(2C)_. Поскольку при вызове новой программы _pid_ не меняется, как и многие другие атрибуты процесса, то считается, что процесс остался тот же самый, но программа в нём была заменена.  

#### Виртуальная память
Семейство ОС UNIX использует виртуальную память, метод при котором происходит отображение адреса памяти, которым оперирует пользовательская программа, на адреса физической оперативной памяти. Трансляцию виртуальных адресов в физические осуществляет ___диспетчер памати___.  

Главной ф-цией виртуальной памяти является защита памяти процессов друг от друга, а ядра системы от обращения к ней процессов напрямую. Дело в том, что во время исполнения программы могут возникнуть ошибки работы с памятью - выход за границы массива, обращение по неинициализированному указателю и т.д. Также злоумышленником может быть модифицирован код ядра для совершения различных вредоносных действий - доступа к данным других процессов, запуска врусов и пр.   

Для защиты от всех этих действий ОС при помощи диспетчера памяти ограничивает диапазон виртуальных адресов, к которым может обращаться пользовательская программа и отображает эти диапазоны адресов разных процессов на разные страницы физической памяти. Таким образом, процесс не может обратиться к памяти ядра или другого процесса.  

#### Виртуальное адресное пространство

Диапазон адресов виртуальной памяти, которая доступна процессу, наз-ся ___виртуальным адресным пространством___ процесса.  

#### Режимы работы

Все процессоры, имеющие диспетчер памяти имеют хотя-бы два режима работы - _пользовательский_ и _системный_. Семейство UNIX использует эти два режима. _Пользовательскй_ - режим с нисшим уровнем привелегий, _системный_ - режим с наивысшим уровнем привелегий. __TODO: закончить...__

#### Структуры процесса

Виртуальная память процесса содержит следующие структуры:
* __текст__
* __данные__
* __пользовательский стек__
* __куча__
* __динамические сегменты__

_Текст_ содержит исполняемый код программы нашего процесса. _Данные_ имеют два сегмент - _DATA_ (инициализированные статические и внешние переменные) и _BSS_ (неинициализированные статические данные и внешние переменные). _Пользовательский стек_ - стек автоматической памяти программы, на котором храняться локальные переменные, аргументы вызова ф-ций, их возвращаемые значения и другая информация. _Куча_ - участок динамической памяти. _Динамические сегменты_ - сегменты кода и данных разделяемых библиотек, отображённые на память файлы и др.  

Также нужно упомянуть связанную с процессом структуру, которая храниться в памяти ядра - _пользовательская область_ процесса или _user area_. В данной структуре храниться информация о процессе, необходимая для его исполнения - _атрибуты процесса_; например, дескрипторы открытых файлов, информация о системных ресурсах, реакции на сигналы, параметры командной строки и пр.

Также, пользовательская область хранит стек, которым ядро пользуется при выполнении системных вызовов. Если в процессе присутствует, несколько нитей, то на каждую нить в пользовательской области выделяется отдельный стек, чтобы системные вызовы в каждой нити могли выпоняться независимо.


# POSIX THREAD LIBRARY

### Введение

#### Потоки

Для исполнения программ в UNIX-системах используются процессы. Каждый процесс является совего рода окружением для исполняемой программы, содержащий собственное виртуальное адресное пр-во и другие ресурсы. Для каждого процесса создаётся иллюзия последовательного исполнения. Взаимодействие процессов возможно только при использованиии системных вызовов, напрямую процесс не может обратиться к данным другого.

Существует ряд задач, требующих некой параллельной обработки данных. Традиционным решением в UNIX было бы использование нескольких параллельно работающих и взаимодействующих между собой процессов. Однако, для решения подобных задач использование этих средств является неоптимальным, а иногда и вовсе неприемлемым. Также была потребность переноса приложений с ОС, допускавших несколько нитей исполнения в рамках одного процесса, на UNIX.  

По этим причинам, в UNIX было введено понятие _нити_ или _потока_ (_thread_). 
* __поток__ - единица планирования в рамках одного процесса.  

Нити процесса разделяют одно общее адресное пр-во, но планируются независимо. Иллюзия последовательного исполнения создаётся именно для нити, а не для процесса в целом.

#### Сборка приложений с использованием POSIX THREAD LIBRARY
Для GCC компилятора:
``` shell
gcc -o labn -threads -lpthread labn.c 
```

или

``` shell
gcc -o labn -pthread -lpthread labn.c 
```


Для Sun Studio 11

``` shell
cc -o labn -mt -lpthread labn.c 
```

При указании ключа _-mt_ или _-pthread_ (_-threads_) при компиляции и сборке, переменная _errno_ становится макроопределением, позволяющее каждому потоку иметь своё собственное _errno_. Значение данного макроопределения можно переинициализировать или же просто использовать, как если бы оно было обычной переменной.

Ключ _-lpthread_ интерпретируется компилятором следующим образом. У данного ключа параметром указана строка pthread, в начало к нему добавляется строка lib, в конце .so или .a, в зависимости от типа сборки - статической или динамической. В результате получается строка libpthread.so, соответсвующая имени библиотеки _posix threads_

#### Реализация многопоточности

Стандарт POSIX допускает различные подходы к реализации многопоточности. Рассмотрим три основных:  

* Нити в пределах одного процесса (в пользовательском адресном пр-ве) переключаются собственным _пользовательским планировщиком_.  

* Переключение между нитями осуществляется _системным планировщиком_, так же, как и при переключении между процессами.  

* Гибридная реализация, при которой каждому процессу выделяется некоторое кол-во системных нитей, при этом процесс также имеет свой собственный пользовательский планировщик в пользовательском адресном пр-ве.  
     
_Примечание:_ в данном контексте _пользовательской нитью_ является нить, планируемая _пользовательским планировщиком_, а _системной нитью_ - нить, планируемая системным планировщиком соответственно. В большинстве UNIX-системах в т.ч. в Solaris системные нити называются _LWP - Light Weight Process_.

__использование пользовательского планировщика__

Достоинством данного варианта является то, что он может быть реализован без изменений ядра системы. Когда системный планировщик передаёт планирование процессора на какой-то процесс, пользовательский планировщик этого процесса может решить, какой из пользовательских нитей передать управление.  

Однако, при практическом применении такого планировщика возникает серьёзная проблема. Если одна из нитей процесса выполнит блокирующийся системный вызов, то тогда заблокируется весь процесс. Решение данной проблемы потребует произвести серьёзные изменения в ядре операционной системы, что в итоге сводит на нет главное достоинство пользовательского планировщика.

__использование системного планировщика__

Ядро типичной ОС уже имеет системный планировщик, который переключает управление между процессами. Переделать этот планировщик для того, чтобы он также мог переключать несколько нитей одного процесса относительно нетрудно. Возможны два способа это сделать:
     
1. Нить является подчинённой, по отношению к процессу сущностью. Идентификатор нити состоит из идентификатора процесса и собственного идентификатора нити, уникального в рамках данного процесса. (А вчём подход то??) Большинство UNIX-систем использует именно такой подход, в т.ч. и Solaris 10.

2. Нить является сущностью того же уровня, что и процесс. __?__

Поскольку ОС с данным подходом реализации многопоточности (в частности Solaris 10 и Linux) используют именно системные нити, то каждому потоку POSIX Thread API соответствует отдельный LWP.

### Описание библиотечных функций для Solaris 10 и концепций POSIX THREAD LIBRARY

* __pthread_create__  - функция создания новой нити в текущем процессе. [Документация.](https://docs.oracle.com/cd/E26505_01/html/816-5168/pthread-create-3c.html#scrolltoc)  

__сигнатура:__
``` C
#include <pthread.h> 

int pthread_create(pthread_t *restrict thread,
     const pthread_attr_t *restrict attr,
     void *(*start_routine)(void*), void *restrict arg);
```
__описание работы:__
Функция создаёт новую нить в текущем процессе с атрибутами указанными параметром _attr_. Если данный параметр равен _NULL_ используются атрибуты по умолчанию. При последующей модификации атрибутов указанных в _attr_ атрибуты самой нити не модифицируются.  

После создания поток исполняет функцию _start_routine_ с параметром, указанным в _arg_. В случае, если данная функции возвращает результат, то это имеет тот же механизм работы, что и вызов _pthread_exit()_ с возвращаемым значением в качестве статуса выхода.  

Однако, для потока, в котором исполняется _main()_ ситуация отличается:
Когда происходит возврат из функции _main()_ это эквивалентно вызову _exit()_ с возвращаемым значением _main()_ в качестве кода выхода.  

В случае успеха, создаётся новый поток, как описано выше и _pthread_create()_ возвращает 0. В противном случае, нового потока не создаётся, содержание данных, на которые указывает аргумент _thread_ не определено. Также функция возвращает код ошибки:  

```
     EAGAIN - системе не хватает ресурсов для создания нового потока, или было превышенно 
     установленное системой максимальное кол-во потоков в процессе.

     EINVAL - значение attr некорректно.

     EPERM - у вызывающего потока нет необходимого разрешения для установки 
     необходимых параметров планирования или политики планирования.
```

---

* __pthread_exit()__ - данная ф-ция завершает исполнение потока.

__сигнатура:__

``` C
#include <pthread.h>

void pthread_exit(void *value_ptr);
```
Если атрибут потока _detachstate_ имеет значение PTHREAD_CREATE_JOINABLE, статус выхода, указанный параметром _value_ptr_ становится доступным при вызове _pthread_join()_ к текущему потоку.

Все обработчики прерывания после вызова _pthread_exit()_ изымаются из стека и исполняются в порядке _FILO_. (Про обработчики прерывания нити будет написано позже.)

Неявный вызов _pthread_exit()_ происходит, когда в поток, отличный от _main_, возвращается из ф-ции, с которой он создавался, посредством оператора _return_. В данном случае, возвращаемое знаение ф-ции можно считать статусом выхода в _pthread_exit()_.

__возвращаемые значения:__

Данная ф-ция не может вернуться к вызыващему её потоку, поскольку она его завершает.

__коды ошибок:__
```
ошибки не определены
```

---

* __pthread_join()__ - ф-ция ожидания завершения нити.

__сигнатура:__
``` C
#include <pthread.h>

int pthread_join(pthread_t thread, void **status);
```

Данная ф-ция приостанавливает работу вызывающей нити, до тех пор, пока целевая нить, указанная параметром _thread_ не завершиться. Целевой поток должен бть чатью текущего процесса и не может иметь значение атрибута _detachstate_ равное _PTHREAD_CREATE_DETACHED_.

Если несколько потоков ожидает завершение целевой нити через _pthread_join()_, то когда данная нить завершиться один из потоков вернётся из _pthread_join()_ успешно, а другие с ожибкой _ESRCH_.

В случае успешного завершения данной ф-ции параметр _status_, если он не равен _NULL_, будет указывать на область памяти, куда было записано возвращаемое значение из _start_routine_.

__возвращаемые значения:__

_pthread_join()_ возвращает 0, в случае успеха и код ошибки, в противном случае.

__коды ошибок:__

```
EDEADLK - поток ожидает завершение самого себя, тем самым порождая мёртвую блокировку.

EINVAL - целевой поток, имеет значение атрибута detachstate равное PTHREAD_CREATE_DETACHED.

ESRCH - указан некорректный идентификатор потока thread.
```

---

__атрибуты нити:__
При создании нити можно указать ей блок атрибутов при помощи параметра _attr_. Данный блок представляет из себя структуру _pthread_attr_t_. Ниже приведён список с описанием основных атрибутов нити. Кроме этих атрибутов структура _pthread_attr_t_  содержит некоторые другие (например _cancelation state_ и _cancelation type_, которые будут рассмотрены позже). 

Для каждого атрибута из блока _pthread_attr_t_ определены ф-ции установки и взятия значения вида (get/set) - _pthread_attr_set$AttributeName$_ и _pthread_attr_get$AttributeName$_. Изменение атрибутов в структуре _pthread_attr_t_ не повлияет на атрибуты нитей, которые были уже созданы с ней. Таким образом, одну и ту же структуру _pthread_attr_t_ можно использовать для инициализации нескольких нитей.

Некоторые атрибуты самой нити могут быть модифицированны после её создания, наример __detachstate__ и __priority__.

* __scope (область действия)__ - допустимые значения:  _PTHREAD_SCOPE_SYSTEM_ и _PTHREAD_SCOPE_PROCESS_.
     * _PTHREAD_SCOPE_SYSTEM_ - нить планируется системным планировщиком и соревнуется за системные ресурсы с другими процессами. 
     * _PTHREAD_SCOPE_PROCESS_ - нить планируется пользовательским планировщиком и считается частью своего роцесса (__по умолчанию__ для Solaris). 

     Solaris и Linux являются ОС, в которых многопоточность имеет реализацию через _системный планировщик_ и каждый поток соответствует собственному _LWP_, поэтому данный атрибут не имеет практического значения. В Linux данный атрибут может быть равен только _PTHREAD_SCOPE_SYSTEM_, в Solaris 10 таких ограничений нет, но атрибут всё-равно бесполезен. В таком случае, правильнее было бы указать _PTHREAD_SCOPE_SYSTEM_ как значение по умолчанию для Solaris, но имеем, что имеем.   
<br/>

* __detachstate (присоединён/отсоединён)__ - Допустимые значения: _PTHREAD_CREATE_JOINABLE_ и _PTHREAD_CREATE_DETACHED_.
     * _PTHREAD_CREATE_DETACHED_  - ресурсы нити будут озвобождениы сразу после её завершения.
     * _PTHREAD_CREATE_JOINABLE_ - ресурсы нити будут освобождены после того, как другая нить вызовет _pthread_join()_ к ней.
<br/>

* __stacksize (размер стека)__ - допустимые значения: 0 или размер стека в байтах. 0 означает, что расмер стека определяется операционой системой. В Solaris 10 на 32-битной архитектуре стек выделяется размером __1mb__, на 64-битной - __2mb__. Минимальный размер стека, который можно выделить нити, определён константой _PTHREAD_STACK_MIN_ в <pthread.h>.
<br/>

* __stack_addr (адрес начала стека)__ - Допустимые значения: NULL(адрес определяется ОС) или указатель на область памяти для размещения стека нити. Не рекомендуется выделять память под стек самостоятельно, поскольку, в таком случае, система не будет освобождать эту память автоматически, это должен реализовать программист __?__.

* __Concurrency__ (степень параллелизма) - допустимые значения: положительные целые числа. В системах с гибридной реализацией планирования нитей, данной значение с определённым приближением соответствует кол-ву системных нитей, создаваемых системой для текущего процесса.

 В Solaris 10 данный атриут игнорируется и нужен только для совместимости со стандартом POSIX. 

 * __Schedpolicy__ (политика планирования) - допустимые значения: Допустимые значения – SCHED_FIFO, SCHED_RR и SCHED_OTHER.
     * SCHED_FIFO - планирование нитей осуществляется в порядке линейной очереди. Также, при данной политике планирования, после получения управления нить отдаст его только, когда заблокируется на примитиве синхронизации.

     * RR - планирование нитей осуществляется в порядке кольцевой очереди. Нить, получившая управление отдаёт его по истечении кванта времени, либо до момента явной отдачи управления. При отдаче управления нить помещается в конец очереди.

     * SCHED_OTHER - данное значнение соответствует системной политк планирования. 

| атрибут | значение по умолчанию | описание |
| ----| ---| ---|
| scope | PTHREAD_SCOPE_PROCESS | Нить планируется пользовательским планировщиком. В Solaris 9 и последующих версиях Solaris этот параметр не имеет практического значения|
| detachstate | PTHREAD_CREATE_JOINABLE | нить создаётся присоединённой |
|stackaddr | NULL | адрес начала стека нити определяется системой | 
| stacksize | 0 | размер стека нити определяется системой | 
| priority | 0 | нить имеет приоритет 0 |
| inheritsched | PTHREAD_EXPLICIT_SCHED | Нить не наследует приоритет у родительской нити |
| schedpolicy | SCHED_OTHER | Нить использует фиксированные приоритеты, задаваемые ОС. Используется вытесняющая многозадачность (нить исполняется, пока не будет вытеснена другой нитью или не заблокируется на примитиве синхронизации) |

## Прерывание нити

Здесь описываются концепции прерывания нити определённые в POSIX thread. Прерывание позволяет потоку процесса завершить своё исполнение.

__Функции__:
| имя | описание |
|---|---|
| pthread_cancel() | прерывание исполнения потока |
| pthread_setcancelstate() | установка атрибута потока ___cancel state___ |
| pthread_setcanceltype() | установка атрибута потока ___cancel type___ |
| pthread_testcancel() | установка ___точки прерывания___ у текущего потока|
| pthread_cleanup_push() | добавление функции обработчика прерывания |
| pthread_cleanup_pop() | изымание функции обработчика прерывания |

* __pthread_cancel()__ - данная функция принудительно завершает нить. Если точнее, делает запрос нити на прерывание. [Документация](https://docs.oracle.com/cd/E26505_01/html/816-5168/pthread-cancel-3c.html#scrolltoc).

__сигнатура:__

``` C
#include <pthread.h> 

int pthread_cancel(pthread_t target_thread);
```

В зависимости от св-в нити и других обстоятельств она может продолжить своё исполнение на некоторое время после вызова _pthread_cancel()_ к ней. Механизм прерывания контролируется атрибутами _cancellation state_ и _cancellation type_.  

В случае успеха, функция возвращает 0, в противном случае - код ошибки.  

__Коды ошибок:__
```
ESRCH - некорректное значение идентефикатора потока - target_thread.
```
----
* __pthread_setcancelstate()__ - устанавливает значение атрибута _cancellation state_ делает это _атомарно_. Это значение определяет разрешено ли прерывание нити в принцыпе. [Документация](https://docs.oracle.com/cd/E26505_01/html/816-5168/pthread-setcancelstate-3c.html#scrolltoc)  

__сигнатура:__
``` C
#include <pthread.h>

int pthread_setcancelstate(int state, int *oldstate);
```
Параметр _state_ - значение, которое будет установлено в атрибут _cancellation state_, параметр _old state_ служит для получения старого значения _cancellation state_. Если _old state_ не равен NULL, то в область памяти, на которую указывает _old state_ будет помещено предыдущее значение _cancellation state_.

Параметр _state_ может принимать следующие значения:

```
PTHREAD_CANCEL_ENABLE - прерывание нити разрешено. (По-умолчанию)

PTHREAAD_CANCEL_DISABLE - прерывание нити запрещено.
```
__Возвращаемые значения:__

В случае успеха, функция _pthread_setcancelstate()_ вернёт 0. В противном случае - код ошибки.

__Коды ошибок:__

```
EINVAL - значение state не является одним из предложенных - PTHREAD_CANCEL_ENABLE, PTHREAAD_CANCEL_DISABLE.  
```
---
* __pthread_setcanceltype()__ - установка атрибута потока  _cancellation type_, который определяет в каких точках программы поток может быть прерван.  

__сигнатура:__

``` C
#include <pthread.h>

int pthread_setcanceltype(int type, int *oldtype);
```

Параметры _type_ и _oldtype_ - значение, которое будет установлено в атрибут _cancelation type_ и ссылка на область памяти, в которую будет помещено старое значение _cancelation type_ соответсвенно. Всё аналогично ф-ции _pthread_setcancelstate()_.

Параметр _type_ может принимать следующие значения:
```
PTHREAD_CANCEL_DEFERRED - когда прерывание нити разрешено (cancelation state=PTHREAD_CANCEL_ENABLE) нить получает сообщение о 
прерывании и, собственно, ожидает прерывания по достижении точки отмены (cancelation point). Если прерывание запрещено, 
то все сообщения о прерывании остаются в ожидании.
(По-умолчанию)

PTHREAD_CANCEL_ASYNCHRONOUS - если прерывание нити разрешено, то оно происходит как можно скорее. Если прерывание запрещено,
то сообщения о прерывании остаются в ожидании. Когда прерывание вновь станет разрешено, все накопренные запросы на отмену
выполнятся немедленно.
```

__Возвращаемые значения:__

В случае успеха, функция _pthread_setcanceltype()_ вернёт 0. В противном случае - код ошибки.

__Коды ошибок:__

```
EINVAL - значение type не является одним из предложенных - PTHREAD_CANCEL_DEFERRED, PTHREAD_CANCEL_ASYNCHRONOUS.  
```

Для упрощения понимания контроля прерывания, ниже приведена таблица где каждой паре значений _cancelation type_ и _cancelation state_ соответствует описание того, как происходит прерыание нити:

|Cancelation Type \ Cancelation State|PTHREAD_CANCEL_ENABLE|PTHREAAD_CANCEL_DISABLE|
|--|--|--|
|__PTHREAD_CANCEL_DEFERRED__|Прерывание происходит, когда нить ожидает прерывания по достижении точки отмены. (По-умолчанию)|Все запросы на прерывание нити остаются в ожидании.|
|__PTHREAD_CANCEL_ASYNCHRONOUS__|Вызов _pthread_cancel()_ осуществляет прерывание нити, как можно скорее.|Все запросы на прерывание остаются в ожидании. Когда прерывание снова будет доступно, все ожидающие запросы выполнятся немедленно.|

#### Точки отмены

Операционной системой определены так называемые _точки отмены_ (_cancelation points_), по достижении которых, может происходить прерывание нити. Это некоторые библиотечные ф-ции и системные вызовы, список которых можно посмотреть [здесь](https://docs.oracle.com/cd/E26505_01/html/816-5175/cancellation-5.html#REFMAN5cancellation-5).  

Также, программист может указать точки прерывания явно, посредством вызова ф-ции _pthread_test_cancel()_.

* __pthread_testcancel()__ - устанавливает явную точку отмены.

__сигнатура:__
``` C
#include <pthread.h>

void pthread_testcancel(void);
```

__Возвращаемые значения:__

Данная ф-ция возвращает _void_.

__Коды ошибок:__

Не возвращает ошибок.

#### Обработчики прерывания

При завершении нити может возникнуть необходимость освободить некоторые ресурсы, вернуть данные в соглассованное состояние или провести какие-то другие манипуляции, которые необходимы именно перед завершением нити.

Для таких целей можно добавить _обработчики прерывания_. Функции, которые будут вызваны нитью, после получения сообщения о прерывании. Данные обработчики, по сути, являются обычными функциями, объединённых в стековую структуру, над которой можно производить операции добавления и извлечения.  

Обработчики прерывания необходимо добавлять до точек отмены. В случае асинхронного прерывания - до момента, где это может произойти.  

* __pthread_cleanup_push()__ - добавляет функцию обработки прерывания в стек (имеется в виду не стек процесса, а отдельная структура для каждой нити) вызывающей нити.

__сигнатура:__
``` C
#include <pthread.h>

void pthread_cleanup_push(void (*handler) (void *), void *arg);
````

Аргумент _handler_ - это, собственно, вызываемая функция-обработчик, _arg_ - её аргумент.  

Когда поток завершается или прерывается и стек обработчиков не пуст, они извлекаются и выполняются в порядке LIFO, т.е. в порядке извлечения элементов из стека.

__Возвращаемые значения:__

Ф-ция ничего не возвращает.

__Коды ошибок:__

Не возвращает ошибок.

---

* __pthread_cleanu_pop()__ - извлекает ф-цию обработчик с вершины стека и, в зависимости от аргумента, исполняет её.  

__сигнатура:__

``` C
#include <pthread.h>

void pthread_cleanup_pop(int execute);
```

Если аргумент _execute_ не нулевой, то происходит извлечение ф-ции обработчика с вершины стека и её исполнение. Если _execute_ = 0, то ф-ция извлекается с вершины стека без последующего исполнения.  

__Возвращаемые значения:__

Ф-ция ничего не возвращает.  

__Коды ошибок:__

Не возвращает ошибок.  

Ф-ции _pthread_cleanup_push()_ и _pthread_cleanup_pop()_ реализованы в виде макрокоманд. Вызов _pthread_cleanup_push()_ должен сопровождаться парным вызовом _pthread_cleanup_pop()_ в одной и той же лексической области:

``` C
void *print_text() {
  pthread_cleanup_push(cleanup_handler, NULL);  // push cleanup routine to the stack

  while (1) {
    pthread_testcancel();
    printf("%s\n", printing_text);
    usleep(PRINT_DELTA_TIME);
  }
  pthread_cleanup_pop(1);

  return NULL;
}
```

Это связано с тем, что макрос _pthread_cleanup_push()_ начинается токеном '{', а _pthread_cleanup_pop()_ завершается токеном '}', поэтому, попытка вызвать любую из этих команд без соответсвующей пары приведёт к ошибке компиляции.  

#### Потокобезопасность

Библиотеки и функции имеют уровни поддержки многопоточности, описываемые атрибутом __MT-Level__. Его возможные значения и их смысл подробно описаны [здесь.](https://docs.oracle.com/cd/E26505_01/html/816-5175/attributes-5.html#scrolltoc)  

Отдельно выделены уровни безопасности прерывания _Asynchronous-Cancel-Safe_ и _Deferred-Cancel-Safe_, о которых написано ниже.  

#### Безопасность прерывания

Во время прерывания потока возможна сетуация, когда используемые потоком ресурсы остаются в несогласованном состоянии. К примеру, прерывание может произойти в момент, когда ресурсы, используемой потоком динамической памяти не успели освободить, или когда поток не разблокировал захваченные примитивы синхронизации. В подобных ситуациях, если стек обработчиков прерывания потока не содержит ф-ций, вызов которых в соответствующем порядке не приводит используемые ресурсы в согласованное состояние, то тогда приложение/ф-ция/библиотека в контексте которой всё это происходит является ___небезопасной для прерывания___.  

Все приложения, в коде которых имеются вызовы _pthread_cancel()_ должны учитывать, что эти вызовы должны исполняться в ___безопасной для прерывания___ среде.  

Для характеристики безопасности прерывания в атрибуте MT-Level выделены отдельные значения - _Asynchronous-Cancel-Safe_ и _Deferred-Cancel-Safe_. Которые означают, что ф-ция/библиотека безопасна для __асинхронного__ прерывания (_PTHREAD_CANCEL_ASYNCHRONOUS_) и для __отложенного__ прерывания (_PTHREAD_CANCEL_DEFERRED_) соответственно.  

### Проблемы конкуренции

В многопоточной среде возможна ситуация когда несколько потоков обращаются к одному и тому же ресурсу. Каждый из потоков может делать с этим ресурсум какие-то манипуляции, не задумываясь о том, что проделанные им изменения, повлияют на работу других потоков, когда они к этому ресурсу будут обращаться.    

Проблемы нет, если доступ к этому ресурсу у потоков строго последовательный, проблема возникает тогда, когда во время проведения потоком какого-то набора операций над ресурсом в это же самое время другие потоки могут этот самый ресурс изменить или просто обратиться к его значению.  

Рассмотрим следующий сценарий работы. Предположим один поток выполняет над ресурсом какой-то набор операций и не предполагает, что во время этого, значение ресурса будет меняться со стороны. Тогда, работа потока будет иметь некорректный результат, поскольку последовательность промежуточных результатов была нарушена со стороны. Ещё возможен следующий сценарий. Пусть два потока выполняют над ресурсом набор операций. И один из потоков предполагает, что он обратиться к ресурсу, когда второй завершит свой набор операций над ним. В таком случае, возможна ситуация, что второй поток ещё не завершил свой набор операций, а первый уже обратился к значению ресурса. Тогда, результат работы первого потока будет некорректен, поскольку тот использовал старое значение ресурса.  

Теперь, конкретный пример. Предположим мы хотим реализовать последовательное инкрементирование целочисленной переменной двумя потоками. Сценарий работы нашего алгоритма может быть следующий: поток __A__ копирует значение переменной в регистр, производит над значением в регистре операцию инкрементирования, в результате получает __6__. В это же время, поток __B__ также копирует значение переменной и производит операцию инкрементирования, до того, как поток __A__ успел сохранить свой результат. Потом, поток __A__ сохраняет свой результат в переменную, затем, то же самое делает и поток __B__. По итогу мы имеем, что значение нашей переменной равно __6__, а не __7__, которое мы расчитывали получить.

#### Примитивы синхронизации

Тут следует ввести термин - __разделяемый ресурс__.

* __Разделяемый ресурс__ - ресурс, к которому возможен совместный доступ со стороны нескольких потоков или процессов.

Ресурс в данном случае является абстрактным понятием, этим может быть любая вещь, которую используют потоки. Это могут быть файлы, данные, вызовы ф-ции и т.д.  

Реализация корректного многопоточного доступа к разделяемым ресурсам решается на практике главным образом за счёт концепции __критических секций__ и взаимоисключающего доступа к ним. Дадим определение критической секции.

* __критическая секция__ - участок кода, при вхождение в который, поток полагается на целостность разделяемого ресурса, или же нарушает эту целостность.

Под _целостностью_ или _согласованностью_ подразумевается соответствие ресурса некоему состоянию, которое является допустимым при обращении потока к этому ресурсу.

Взаимоисключающий доступ к критической секции означает, что в один момент времени внутри секции может находиться не более одного потока.

Для того, чтобы реализовать взаимоисключающий доступ к критической секции невозможно использовать простую флаговую переменную, поскольку последовательность операций проверки и установки флаговой переменной сама по себе является критической секцией. Существуют алгоритмы реализации взаимоисключающего доступа при помощи нескольких флаговых переменных, например [алгоритм Деккера](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%94%D0%B5%D0%BA%D0%BA%D0%B5%D1%80%D0%B0). Однако, такие алгоритмы плохо масштабируются на произвольное кол-во потоков, поэтому в многопоточном программировании практически не применяются.  

В современных операционных системах для реализации корректного многопоточного доступа к разделяемым ресурсам используются более сложные _примитивы синхронизации_ (под _примитивом_ подразумевается тип данных, над которым определён фиксированный набор операций). Которые реализуют проверку флага и засыпание, пробуждение и установку флага, сброс флага и пробуждение другой нити, как __атомарные операции__. Т.е. те операции, которые всегда выполняются полностью и выполняются только одним потоком в данный момент времени.  

#### Мьютекс

Одним из таких примитивов синхронизации является __мьютекс__ от английского _mutual exclusion_ - взаимное исключение. У мьютеса может быть два состояния _свободен_ и _захвачен_. И определены две соответствующие операции - _lock_ (блокировка) и _unlock_ (снятие блокировки). Если нить попытается заблокировать захваченный мьютекс, то это приведёт к её засыпанию (блокировке на мьютексе). Блокировка свободного мьютекса приведёт его в захваченное состояние. Операция освобождения свободного мьютекса является недопустимой (в програмных реализациях это приводит к ошибке). Освобождение занятого мьютекса переведёт мьютекс в свободное состояние, если в этот момент на мьютексе были заблокированны другие нити, то одна из них просыпается и захватывает мьютекс.  

Согласно данной семантики операций над мьютексом, захват и освобождение мьютекса производятся одной и той же нитью, поэтому можно говорить, что у мьютекса есть _владелец_, т.е. тот поток, который последним его заблокировал и ещё не снял блокировку.  Наличие потока-владельца является главной особенностью мьютекса.  

Мьютекс имеет очевидное применение для решения задачи взаимоисключения. С каждым разделяемым ресурсом мы связываем мьютекс. На входе критической секции этого ресурса нить мьютекс захватывает, а на выходе освобождает.  

#### Семафор

Примитив синхронизации, реализованный на базе целочисленного счётчика, принимающего неотрицательные значения. Семафор поддерживает атомарные операции инкрементирования и декрементирования счётчика. Декрементирование счётчика со значением 0 является блокирующимся, т.е. поток пытающийся это сделать засыпает (блокируется) до тех пор, пока значение счётчика снова не станет больше нуля.

Семафоры можно использовать, как счётчики кол-ва свободных ресурсов. Для получения ресурса, поток производит операцию декрементирования счётчика семафора и получает свой ресурс. Возвращая ресурс после работы, поток инкрементирует счётчик семафора. Тем самым, если свободных ресурсов нет, потоки, пытающиеся их получить, засыпают.

Также, семафоры можно использовать для защиты критических секций. Если взять начальное значение счётчика семафора за 1, при входе в критическую секцию дикрементировать значение счётчика, а при выходе инкрементировать, то тогда мы получим необходимый нам взаимоисключающий доступ к критической секции.

#### Отличия

Однако, у семафоров и мьютексов есть одно существенное отличие - у мьютекса есть владелец, а у семафора нет. Снять блокировку с мьютекса может только тот поток, который последним его заблокировал. У семаформа менять значение счётчика может любой поток. Для осознание того, на сколько это различие существенно, рассмотрим пример с критической секцией. В одном случае взаимоисключающий доступ к ней реализовн при помощи мьютекса, в другом с помощью семафора. В случае мьютекса, никакой другой поток, кроме владельца не может снять блокировку с мьютекса, таким образом в критической секции гарантированно может исполняться только один поток. В случае с семафором возможно следующее. Поток декрементировал счётчик с __1__ в __0__ и вошёл в критическу секцию, а в это время какой-то сторонний поток решил увеличить значение счётчика, таким образом, к критической секции получили доступ другие потоки, помимо того, который сейчас в ней исполняется.  

Таким образом, для защиты критических секций используют именно мьютексы, поскольку это надёжно, в отличии от использования для этой цели семафоров.

#### Реализация в POSIX

__Мьютексы__

Мьютексы можно создавать для синхронизации потоков в одном процессе или же для синхронизации потоков в разных процессах. Во втором случае мьютекс требуется создать в разделяемой между соответсвующими процессами области памяти.

* __pthread_mutex_init()__ - инциализирует структуру мьютекса _pthread_mutex_t_. [Документация.](https://docs.oracle.com/cd/E26505_01/html/816-5168/pthread-mutex-init-3c.html#scrolltoc)

__сигнатура:__

``` C
#include <pthread.h> 

int pthread_mutex_init(pthread_mutex_t *restrict mutex,
     const pthread_mutexattr_t *restrict attr);
```

Ф-ция инициализирует структуру _pthread_mutex_t_ по указателю _mutex_. Параметр _attr_ указывает на структуру параметров мьютекса типа _pthread_mutexattr_t_, которыми мьютекс будет инициализирован. Если значение _attr_ равно NULL, то мьютекс инициализируется атрибутами по-умолчанию. В случае успешного завершения, мьютекс инициализируется и является незаблокированным. В случае выполнения других операций над неинициализированным мьютексом, результат будет неопределён.

Перед освобождением памяти из под мьютекса его необходимо уничтожить, вызвав _pthread_mutex_destroy_ (будет рассмотрено далее).

__возвращаемые значения__

В случае успеха, ф-ция возвращает 0, в противном случа - код ошибки.

__коды ошибок__

```
EAGAIN - The system lacked the necessary resources (other than memory) to initialize another mutex.

EBUSY
An attempt was detected to re-initialize a robust mutex previously initialized but not yet destroyed. See pthread_mutexattr_setrobust_np(3C).

EINVAL
An attempt was detected to re-initialize a robust mutex previously initialized with a different set of attributes. See pthread_mutexattr_setrobust_np(3C).

ENOMEM
Insufficient memory exists to initialize the mutex.

EPERM
The caller does not have the privilege to perform the operation.
```

__Атрибуты мьютекса__

Теперь рассмотим атрибуты мьютекса. Их значения указываются в структуре _pthread_mutex_attr_t_. Изменение полей данной структуры не повлияет на атрибуты мьютексов, которые были ей инициализированы. Таким образом, один объект _pthread_mutex_attr_t_ можно использовать для инициализации нескольких мьютексов.  

Список атрибутов мьютекса следующий:
* ___pshared___
* [type](https://docs.oracle.com/cd/E26505_01/html/816-5168/pthread-mutexattr-settype-3c.html#scrolltoc)
* ___protocol___
* ___prioceiling___
* ___robust_np___

Атрибут __pshared__ отвечает за область действия мьютекса. Данный атрибут имеет два допустимых значения:  

* _PTHREAD_PROCESS_SHARED_ - мьютекс, который можно использовать для межпроцессного взаимодействия. Для того, чтобы использовать такой мьютекс, его необходимо разместить в разделяемой памяти, к которой соответствующие процессы будут иметь доступ.  
<br/>
* _PTHREAD_PROCESS_PRIVATE_ - мьютекс, который используется только для взаимодействия нитей в рамках одного процесса.  

Атрибут __type__ определяет способ проверки ошибок при работе с мьютексом. Допустимые значения:  

* _PTHREAD_MUTEX_NORMAL_ - какие либо проверки на ошибки отсутствуют. Однако, многократный захват такого мьютекса одной и той же нитью приведёт к мёртвой блокировке.  
<br/>

* _PTHREAD_MUTEX_ERRORCHECK_ - все операции над мьютексом сопровождаются проверкой его состояния и возвращают ошибки при недопустимых пос-тях операций. При данном значении атрибута _type_ работа с мьютексом требует гораздо больше вычислений, чем при работе с мьютексом, имеющим значение _NORMAL_.  
<br/>

* _PTHREAD_MUTEX_RECURSIVE_ - допускается многократный захват мьютекса одной и той же нитью. Такой мьютекс хранит счётчик захватов и должен быть осбождён нитью столько раз, сколько она его захватила, чтобы оставить мьютекс в незахваченном состоянии. другие попытки освобождения приводят к ошибке.  
<br/>

* _PTHREAD_MUTEX_DEFAULT_ - в соответствии со стандартом POSIX, проверки на ошибки отсутствуют, при этом повторный захват такого мьютекса нитью может приводить к непредсказуемым последствиям вплоть до аварийного завершения процесса. Реализация стандарта имеет право отображать данное значение _type_ на любое другое. Так, в Solaris 10 значение _PTHREAD_MUTEX_DEFAULT_ соответствует _PTHREAD_MUTEX_NORMAL_. Является значением __по умолчанию__, как не странно.   

Атрибут __protocol__ описывает схему предотвращения инверсии приоритета. Инверсия приоритета - процесс, при котором низкоприоритетная нить удерживает мьютекс, на котором ожидает высокоприоритетная нить. Под приоритетом нити имеется в виду её приоритет на исполнение. Допустимые значения:    

* _PTHREAD_PRIO_NONE_ - не предусматривается никакой борьбы с инверсией приоритета. Значение __по умолчанию__.   
<br/>

* _PTHREAD_PRIO_INHERIT_ - приоритет нити, захватившей мьютекс повышается до самого высокого приоритета из нитей, ожидающих освобождения мьютекса.  
<br/>

* _PTHREAD_PRIO_PROTECT_ - приоритет нити, удерживающей мьютекс равен приоритету, указанному в св-ве _priocelling_ этого мьютекса.  

_Примечание:_ Если нить удерживает несколько мьютексов, то её приоритет, будет равен наибольшему из приоритетов на каждом из этих мьютексов. (Для нитей со значением _protocol_, равному _PTHREAD_PRIO_INHERIT_ и _PTHREAD_PRIO_PROTECT_)  

Атрибут __prioceiling__ задаёт приоритет для мьютексов со значением __protocol__ равным _PTHREAD_PRIO_PROTECT_. Для мьютексов с другим значнением поля __protocol__ данный атрибут игнорируется.  

Атрибут __robust_np__ является атрибутом, который не регламентируется стандартом POSIX (суффикс __np__ означает _not POSIX_). Он реализован в Solaris и появился в версии 2.6 ядра Linux. Данный атрибут определяет поведение, в случае, когда нить, в которой удерживается мьютекс завершается без снятия блокировки с него.   

__robust_np__ может принимать два значения - _PTHREAD_MUTEX_ROBUST_NP_ и PTHREAD_MUTEX_STALLED_NP (__по умолчанию__).  

PTHREAD_MUTEX_STALLED_NP - мутекс, удерживавшийся нитью остаётся в занятом состоянии и попытки новых нитей его захватить блокируются.  

_PTHREAD_MUTEX_ROBUST_NP_ - в данном случае мьютекс реализует более сложное поведение. Нить, первая пытающаяся захватить мьютекс получает ошибку _EOWNERDEAD_ при вызове _pthread_mutex_lock()_, однако, мьютекс она захватывает. После этого нить должна привести разделяемые ресурсы, которые защищал данный мьютекс в согласованное состояние, т.к. они могли остаться несогласованными после завершения нити-хозяина. Если ей это удаётся, то она должна вызвать _pthread_mutex_consistent_np()_, после этого нормальная работа с мьютексом может быть продолжена. Если же в согласованное состояние ресурсы привести не удалось, тогда нить должна просто освободить мьютекс. После этого дальнейшие попытки захватить такой мьютекс будут завершаться с кодом ошибки _ENOTRECOVERABLE_.  
