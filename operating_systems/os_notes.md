# Операционная система UNIX System V Realise 4 (SVR4)
##### Лекционный материал по устройсту операционной системы UNIX (семейства UNIX-подобных операционных систем). Выделяется и описывается то общее, что они имеют, а именно: базовый пользовательский и программный интерфейсы, назначение основных компонент, их архитектура и взаимодействие.

### хронология UNIX System V
* __UNIX System V__ - была выпущена в 1983 году.  
* __System V Release 3 (SVR3)__ - появилась в 1987 году. В этой версии был добавлен ряд дополнительных возможностей:
     * Подсистему ввода/вывода, основанную на архитектуре STREAMS.
     * Переключатель файловой системы (File System Switch), обеспечивавший одновременную поддержку различных файловых систем.
     * Разделяемые(динамические) библиотеки. Библиотеки, которые могут использоваться несколькими приложениями одновременно на стадии исполнения.
     * Программный интерфейс сетевых приложений Transport Layer Interface (TLI).
* __System V Release 4 (SVR4)__ - Была выпущена в 1989 году. Объединяла возможности нескольких версий UNIX: SunOS, BSD UNIX, и предыдущие версии System V. Новые черты системы:
     * Командные интерпретаторы Korn dhell и С shell (BSD)
     * Систему терминального ввода/вывода, основанную на STREAMS (System V)  
     * Быстрая файловую систему FFS (BSD)
     * Сетевой программный интерфейс сокетов (BSD)
     * Отображение файлов в оперативную память (SunOS)
     * Поддержку диспетчеризации реального времени
Также многие компоненты системы были поддержаны стандартами ANSI и POSIX.

### Стандартизация UNIX

UNIX является первой действительно переносимой операционной системой. В свободно распространяемые версии UNIX постоянно вносили изменения, что порождало большое кол-во версий данной системы. И чем дальше, тем больше были различия между существующими версиями. Это вело к отсутствию канонического UNIX и, как следствия усложнению переносимости приложений, написанных под ту или иную версию.

Поэтому появилась необходимость описать стандарты системы. Их наличие обеспечило бы простоту переносимости приложений. В результате возникло несколько организаций по стандартизации, которыми был разработан ряд стандартов, повлиявших на дальнейшую разработку систем UNIX.

### POSIX

Стандарт POSIX (Portable Operating System Interface for Computer Environment) описывает набор услуг, предоставляемых системой приложениям (API), в частности стандартную библиотеку языка С. Тем самым, обеспечивается переносимость приложений на уровне исходного кода. Разные ОС могут иметь разные реализации стандарта. Исполнение прикладной программы для другой реализации стандарта может потребовать перекомпиляции. Связано это стем, что API предоставляет минимальный набор услуг который может как-то дополняться в зависимости от реализации. Так помимо минимального набора полей в структурах данных, зарегламентированных стандартом, в конкретной реализации могт присутствовать ещё какие-то поля, а ф-ции могут иметь реализацию как в виде обычной ф-ции, так и в виде макроса.   

Опишем несколько значимых стандартов POSIX:
* POSIX 1003.1 - был разработан в 1988 году. Определял API.
* POSIX 1003.2 1992 - Включает определение командного интерпретатора UNIX и набора утилит.
* POSIX Содержит дополнения, относящиеся к поддержке приложений реального времени

* POSIX 1003.1c-1995 - Включает определения "нитей" (threads) POSIX, известных также как pthreads.

### Для чего нужна операционная система

Вычислительное оборудование осуществляет выполнение задач, которые на нижнем уровне абстракции представлены в виде набора инструкций. Если мы говорим про процессор, то его ф-ция, по-сути, сводится к выполнению следущих задач: загрузка инструкции из памяти, выполнение данной инструкции, загрузка результата обратно в память. 

Мы можем ввести концепцию пользователя аппаратного ресурса - пользователь это прежде всего тот, кто использует чьи-то услуги, в данном случае услуги проведения операций процессором. Следовательно отдельным пользователем процессора можно считать _задачу_ (набор инструкций) который он исполняет. Здесь мы допускаем обобщение, что _задачей_ является набор инструкций исполняемого файла отдельного _приложения_, таким образом тут имеется взаимно однозначное соответствия пользователя процессора и приложения в ОС. 

Задача использует аппаратные ресурсы - это вычислительные ресурсы процессора, а так же ресурсы памяти для хранения промежуточных результатов своей работы. Здесь возникают следующие проблемы или требования:

* Аппаратных ресурсов в общем случае не бывает много по сравнению с суммарными требованиями конкретной задачи.  

* Использование вычислительного оборудования может подразумевать многозадачность.  

* Одна задача не должна влиять на исполнение другой, если они независимы.  

* Некорректное выполнение задачи не должно приводить аппаратные ресурсы в некорректное состояние.  

* Для удобства переносимости задачи на разные аппаратные платформы нужно абстрагировать аппаратную часть, т.е. сделать так, чтобы приложения использовали апаратные ресурсы через некий интерфейс.  

Для решения всех этих проблем существует ___операционная система___. Т.е. програмное обеспечение, управляющее аппаратным обеспечением устройства, а также предоставляющее програмный интерфейс приложениям - _API_ для взаимодействия с ним.  

В рамках ОС определена абстракция ___процесса___, которая является програмным окружением исполняемой задачи, чуть более точно - это исполняемый код, данные а также управляющая информация для ОС. Абстракция процесса как раз решает задачи изолированной работы приложений друг от друга посредством концепции ___адресного пр-ва процесса___, обеспечения ___многозадачности___ ведь одному процессу взаимно однозначно соответствует одна задача и ОС переключая управления с одого процесса на другой псевдо-параллельно может обеспечить исполнение нескольких задач.  

### Устройство операционной системы

##### Ядро системы
Ядро обеспечивает базовую функциональность операционной системы. Оно создаёт процессы, управляет ими, распределяет память и обеспечивает доступ к файлам и переферийным устройствам.

Взаимодействие прикладных приложений с ядром происходит через ___интерфейс системных вызовов___, который реализован в виде функций стандартной библиотеки языка C. Он представляет из себя набор услуг ядра, который могут использовать приложения. Главным образом, это ф-ции ввода/вывода (файловый, сетевой), межпроцессного взаимодействия, управления памятью, доступ к настойкам системы и глобальным данным (например к показаниям часов).  

Процесс, в котором исполняется приложение, запрашивает услугу ядра посредством ___системного вызова___. Ядро выполняет данный запрос от имени процесса и возвращает ему необходимые данные.  

<a href="https://ibb.co/SRKh8Lc"><img src="https://i.ibb.co/yW8w13p/image.jpg" alt="image" border="0"></a>

### Процесс

Процесом называется экземпляр исполняемой программы вместе с данными этой программы, а также управляющим набором атрибутов, хранящихся в ядре операционной системы.  

Каждый раз при запуске новой программы создаётся новый процесс в рамках которого данная программа исполняется.  

Одним из атрибутов процесса в UNIX является его идентификатор _pid_, который в данный момент времени является уникальным, но может быть переиспользован после завершения процесса.  

Также, в разные моменты времени процесс может исполнять разные программы. Сделать это можно при помощи системного вызова _exec(2C)_. Поскольку при вызове новой программы _pid_ не меняется, как и многие другие атрибуты процесса, то считается, что процесс остался тот же самый, но программа в нём была заменена.  

#### Виртуальная память
Семейство ОС UNIX использует виртуальную память, метод при котором происходит отображение адреса памяти, которым оперирует пользовательская программа, на адреса физической оперативной памяти. Трансляцию виртуальных адресов в физические осуществляет ___диспетчер памати___.  

Главной ф-цией виртуальной памяти является защита памяти процессов друг от друга, а ядра системы от обращения к ней процессов напрямую. Дело в том, что во время исполнения программы могут возникнуть ошибки работы с памятью - выход за границы массива, обращение по неинициализированному указателю и т.д. Также злоумышленником может быть модифицирован код ядра для совершения различных вредоносных действий - доступа к данным других процессов, запуска врусов и пр.   

Для защиты от всех этих действий ОС при помощи диспетчера памяти ограничивает диапазон виртуальных адресов, к которым может обращаться пользовательская программа и отображает эти диапазоны адресов разных процессов на разные страницы физической памяти. Таким образом, процесс не может обратиться к памяти ядра или другого процесса.  

#### Виртуальное адресное пространство

Диапазон адресов виртуальной памяти, которая доступна процессу, наз-ся ___виртуальным адресным пространством___ процесса.  

#### Режимы работы

Все процессоры, имеющие диспетчер памяти имеют хотя-бы два режима работы - _пользовательский_ и _системный_. Семейство UNIX использует эти два режима. _Пользовательскй_ - режим с нисшим уровнем привелегий, _системный_ - режим с наивысшим уровнем привелегий.

* системный режим - в этом режиме исполняемый процессором код может обращаться напрямую к данным ядра операционной системы, осуществлять доступ к внешним устройствам, может менять настройки диспетчера памяти и даже самого процессора. Код, исполняющийся в данном режиме наз-ся _системным_ или _кодом ядра_.

* пользовательский режим - по умолчанию, исполняемый код выполняется в нём. До тех пор, пока не попытается осуществить системный вызов. Когда это происходит, вызывается специальная команда процессора _SYSCALL_, которая переключает режим исполнения кода на системный и передаёт управление по определённому адресу, к которому пользователь доступа не имеет. Таким образом гарантируется, что пользователь не может исполнить системный код, тем самым обеспечивается защита системных ресурсов от несанкционированного доступа.  

Команда включения системного режима передаёт управление диспетчеру системных вызовов. 

#### Структуры процесса

Виртуальная память процесса содержит следующие структуры:
* __текст (TEXT)__
* __данные (DATA + BSS)__
* __пользовательский стек (STACK)__
* __куча (HEAP)__
* __динамические сегменты__

_Текст_ содержит исполняемый код программы нашего процесса. _Данные_ имеют два сегмент - _DATA_ (инициализированные статические и внешние переменные) и _BSS_ (неинициализированные статические данные и внешние переменные). _Пользовательский стек_ - стек автоматической памяти программы, на котором храняться локальные переменные, аргументы вызова ф-ций, их возвращаемые значения и другая информация. _Куча_ - участок динамической памяти. _Динамические сегменты_ - сегменты кода и данных разделяемых библиотек, отображённые на память файлы и др.  

Также нужно упомянуть связанную с процессом структуру, которая храниться в памяти ядра - _пользовательская область_ процесса или _user area_. В данной структуре храниться информация о процессе, необходимая для его исполнения - _атрибуты процесса_; например, дескрипторы открытых файлов, информация о системных ресурсах, реакции на сигналы, параметры командной строки и пр.

Также, пользовательская область хранит стек, которым ядро пользуется при выполнении системных вызовов. Если в процессе присутствует, несколько нитей, то на каждую нить в пользовательской области выделяется отдельный стек, чтобы системные вызовы в каждой нити могли выпоняться независимо.

#### Создание процесса
Процесс может создать один или несколько порождённых процессов, используя системный вызов _fork(2)_. Концептуально порождённый процесс является копией исходного. Реализация такого поведения далее рассматривается более подробно.  

При выполнении _fork(2)_ происходит "наследование" всех сегментов адресного пр-ва родительского процесса, а также его _user-area_. Однако, для разных сегментов это наследование происходит разными способами:

* __user-area__ - как уже было сказано ранее _fork(2)_ создаёт дочерний процесс, но так или иначе он является полноценным процессом, следовательно должен иметь собственную управляющую информацию в ядре операционной системы. Поэтому при наследовании от родительского процесса к дочернему _user-area_ копируется в классическом понимании этого определения. Но копируется не всё: НЕ копируется идентификатор родительского процесса, идентификатор самого процесса (что очевидно), а также НЕ наследуются захваченные файлы и записи, поскольку они являются собственностью процесса.   

* __TEXT__ - Для родительского и дочернего процесса данный сегмент полностью идентичен, что логично, поскольку при возврате из _fork(2)_ оба процесса продолжают исполнять одну и ту же программу с этой точки возврата. _TEXT_ является неизменямым сегментом, и при создании дочернего процесса он соответствует одной и той же области _физической_ памяти, что и у родительского.  

* __Данные__, __пользовательский стек__, __куча__ идентичны у родительского и у дочернего процесса. Эти сегменты копируются по механизму _copy-on-write_. Данный механизм имеет следующий принцип работы - при чтении без какой либо модификации со стороны родительского и дочернего процесса используются одни и те же страницы виртуальной памяти. Но как только, какой-то процесс захотел произвести модификацию, ядро ОС (предварительно установившее защиту на запись в такую страницу) перехватывает эту ситуацию и выделяет такому процессу новую страницу виртуальной памяти, предварительно скопировав в неё данные из первой. Полученная копия отображается в адресное пр-во процесса, который произвёл модификацию. Данная ситуация симметрична и для родительского и для дочернего процесса.

* __динамические сегменты__ - в зависимости от атрибутов, могут быть либо разделяемыми, либо скопированы при помощи _copy-on-write_. Сегменты, отображённые на память с флагом MAP_SHARED являются разделяемыми и соответствуют одной и той же области физической памяти и у родительского и у дочернего процесса. Если сегменты отображались с флагом MAP_PRIVATE или MAP_ANON, то при наследовании происходит копирование по механизму _copy-on-write_.

##### Наследуемые атрибуты
Далее перечислены атрибуты, которые дочерний процесс наследует от родительского при создании:
* идентификаторы пользователя и группы
* переменные окружения
* ограничения процесса __?__
* диспозиция сигналов и их обработки __?__
* текущий и корневой каталог
* маска создания файлов __?__
* все файловые дескрипторы
* управляющий терминал __?__

Есть и некоторые атрибуты, которые у родительского и дочернего процесса различны - это ___идентификатор процесса___ и ___идентификатор родительского процесса___.

#### Завершение процесса

Процесс завершается при помощи системного вызова _exit(2)_. Собственно, он прекращает исполнение вашей программы. Данный вызов происходит неявно после возврата из _main()_. В качестве параметра, _exit(2)_  принимает целочисленное значение в диапазоне 0-255. Общепринятым считается, что 0 обозначает нормально завершение программы, остальные значения соответствуют кодам ошибок.  

_exit(2)_ осуществляет следующие действия:
* закрытие всех файловых дескрипторов процесса.
* исполнение деструкторов статических переменных для (C++ программы)
* вывод буферезированных данных.
* отключает все сигналы __?__
* сохранение статистики использования _вычислительных ресурсов_ (время работы процесса в тактах, использование памяти и т.д.) и кода возврата в таблице процессов. Эти данные доступны родительскому процессу через системный вызов _wait(2)_.
* переводит процесс в состояние "зомби", т.е. фактически этого процесса больше не существует. Остаётся лишь запись в таблице процессов, содержащая код возврата и статистику.
* для всех потомков завершённого процесса родительским процессом становится _init(1M)_
* освобождение адресного пр-ва процесса, _user-area_ 
* родительскому процессу отправляется сигнал _SIGCHLD_ о смерти потомка
* производит запуск ф-ции переключения контекста, в результате чего происходит последующее исполнение более высокоприоритетного процесса

Для каждого процесса-зомби остаётся запись в таблице процессов, соответственно, порождение чрезмерного кол-ва "зомби" может привести к переполнению таблицы процессов. Чтобы решить эту проблему существует системный вызов _wait(2)_, который возвращает данные записи дочернего процесса и удаляет саму запись из таблицы процессов. Вызов _wait(2)_ производит родительский процесс, собственно он и получает информацию о работе дочернего процесса и именно он ответственен за удаление записи дочернего процесса из таблицы.

Если вызов _wait(2)_ не был произведён, то процесс продолжает находиться в состоянии "зомби" до перезапуска операционной системы.  

#### Исполнение программы

Процесс может "заменить" текущую исполняемую программу на новую, посредством системного вызова _exec(2)_. Этот системный вызов не создаёт новый процесс, в отличие от _fork(2)_. Он заменяет текст, данные, стек и все остальные сегменты адресного пр-ва процесса на соответствующие сегменты новой программы и при этом оставляет неизменной _user-area_. Таким образом, можно говорить именно о "замене" программы у __того же самого__ процесса.

Данный системный вызов имеет несколько вариантов:

``` C
#include <unistd.h>

int execl(const char *path, const char *arg0,
     ... /* const char *argn, (char *)0 */);

int execv(const char *path, char *const argv[]);

int execle(const char *path, const char *arg0,
     ... /* const char *argn, (char *)0,char *const envp[]*/);

int execve(const char *path, char *const argv[],
     char *const envp[]);

int execlp(const char *file, const char *arg0,
     ... /* const char *argn, (char *)0 */);

int execvp(const char *file, char *const argv[]);
```

Как видно из сигнатур, после _exec_ следует одна или несколько букв из следующего набора:

l - означает, что ф-ции передаётся список аргументов, т.е. аргументы перечисляются как отдельные параметры через запятую.  
v - ф-ции передаётся вектор аргументов, т.е. отдельным массивом строк.  
e - переменные среды новой программы указываются отдельным аргументом, в виде списка строк.
p - для поиска исполняемого файла программы используется переменная окружения _PATH_. Для этого отдельным аргументом передаётся строка имени файла, которая, в зависимости от своего вида, может быть сконкатенирована с именем дирректории из _PATH_ и в результате будет получен полный путь до исполняемого файла программы.

Перейдём к описанию аргументов:
* _path_ - строка, содержащая абсолютное или относительное имя исполняемого файла.  
* _file_ - строка, содержащая имя исполняемого файла, который лежит в одной из дирректорий перечисленных в _PATH_.
* _arg0, ..., argn_ - передаваемые параметры. Представляют из себя набор строк переданных ф-ции в качестве аргументов через запятую, которые помещаются в массив _argv[]_ - параметр ф-ции _main()_ исполняемой программы. Их кол-во равно значению аргумента _argc_. _arg0_ должен соответствовать имени исполняемой программы.  
* _argv[]_ - массив строк, соответствующих аргументам новой программы. Данный массив должен иметь _NULL_, в качестве последнего элемента.

* _envp[]_ - массив переменных среды передаваемый исполняемой программе. Точно также, как и _argv[]_ должен иметь _NULL_ в качестве последнего элемента.  

В случае успешного завершения, _exec(2)_ не передаёт управления в исходную программу. Образа процесса исходной программы больше не существует. Возврат управления происходит только в случае неудачного вызова _exec(2)_.

__Коды ошибок__
```

```

#### Среда исполнения

__общее описание__

Среда исполнения процесса имеет довольно широкое определение. Она включает в себя экспортированные переменные командного интерпретатора _shell_, открытые файлы, текущую дирректорию, права доступа по умолчанию при создании файла и пр. Большинство параметров среды исполнения процесс наследует от своего родителя, однако при помощи различных системных вызовов параметры среды исполнения можно менять.  

Будет разумно рассмотреть "дерево" процессов при запуске операционной системы, чтобы понять, где же этот самый общий родитель и какую среду исполнения он имеет. Это поможет определить то общее, что имеет каждый процесс в своей среде.  

При запуске операционной системы исполнение всех процессов начинается с процесса _init(1M)_, собственно он и является прародителем всех процессов. Последующие процессы рождаются двумя способами: при помощи связки системных вызовов _fork+exec_, либо просто при помощи _exec_. На рисунке приведеноп дерево процессов в _UNIX_.

Таким образом, начальная среда исполнения инициализируется процессом _init(1M)_ и модифицируется при входе в систему посредством команды _login_. После запуска _login_ при помощи связки системных вызовов _fork+exec_ запускается _shell_, который изменяет среду исполнения посредством интерпретации входного файла "/etc/profile" или же "\$HOME/.profile". В обоих случаях происходит установка переменных среды. Все процессы терминальной сессии являются потомками _shell_, следовательно все они наследуют настройки из /etc/profile и $HOME/.profile

__параметры среды исполнения__

Информация о среде исполнения содержится в двух местах: в _user-area_ и в стеке процесса. Поскольку _user-area_ напрямую недоступна из пользовательского кода, для получения данных оттуда или изменения (если это допустимо) требуется использовать системные вызовы. Информация хранимая в стеке доступна из пользовательского кода напрямую.  

В пользовательской области размещены:

* идентификатор процесса и его родителя
* идентификатор группы процессов __?__
*  Ограничения процесса - максимально доступное время ЦП, максимальный размер сегмента данных, максимальный размер стека, максимальный размер создаваемого файла, максимальное число открытых файлов.
* идентификатор сессии __?__
* права доступа пользователя: реальный и эффективный идентификаторы пользователя, группы, роли. (будет рассмотренно позже)
* информация о файловой системе
* действия, совершаемые при получении сигнала

В стеке также размещена информация о среде исполнения, она передаётся исполняемой программе при системном вызове _exec(2)_ и включает в себя:
* аргументы командной строки - _argc/argv_
* переменные среды - экспортированные переменные командного интерпретаора _shell_, которые влияют на его работу и доступ к ресурсам ОС.  

Аргументы командной строки (argv) и переменные среды представляют из себя наборы строк.

__доступ к среде исполнения__

Доступ к аргументам командной строки можно полуичть привычным для нас способом - посредством обращения к параметру _argv[]_ ф-ции _main()_. Кол-во элементов в нём соответствует значению параметра _argc_, также их можно определить исходя из того, что последний элемент _argv[]_ всегда соответствует _NULL_.

Доступ к _переменным среды_ можно получить через третий аргумент ф-ции _main()_ - _envp[]_ (аналогично, как и для _argv[]_), или через внешнюю переменную _char **envp_, определённую в стандатной библиотеке языка C. Кол-во переменных в этом массиве можно определить исходя из того, что последний элемент _envp_ также соответствует _NULL_.

Как уже было описано ранее, _envp_ содержит список строк. Каждая из них имеет следующий формат: __"name=value"__ , например - __"TZ=Asia/Novosibirsk"__ значение переменной временной зоны.  

Перечислим некоторые библиотечные ф-ции, а также системные вызовы для доступа к параметрам среды исполнения:

``` C
#include <stdlib.h>

char *getenv(const char *name);
int putenv(char *string);

/--------------------------------/

#include <unistd.h>

pid_t getpid(void);
pid_t getppid(void);
pid_t getpgrp(void);
pid_t getpgid(pid_t pid);

/--------------------------------/

#include <sys/types.h>
#include <unistd.h>

uid_t getuid(void);
uid_t geteuid(void);

gid_t getgid(void);
gid_t getegid(void);

/--------------------------------/

#include <sys/types.h>
#include <unistd.h>

int setuid(uid_t uid);
int seteuid(uid_t euid);
int setgid(gid_t gid);
int setegid(gid_t egid);
```

* _getenv()_ возвращает значение переменной среды с указанным именем, если такой переменной окружения нет, товозвращается _NULL_.
* Ф-ция _putenv()_ меняет переменную среды, указанную параметром _string_, который имеет вид "name=value". Если переменной среды с именем _name_ нет, она добавляется.  
* _getpid()_ - получение идентификатора процесса.  
* _getppid()_ - возвращает идентификатор родительского процесса.  
* _getpgrp()_ - получение идентификатора группы текущего процесса.  
* _getpgid()_ - получение идентификатора группы процесса с идентификатором _pid_.  
* _getuid()_ - возвращает реальный идентификатор пользователя.  
* _geteuid()_ - возвращает эффективный идентификатор пользователя.  
* _getgid()_ - возвращает реальный идентификатор группы.  
* _getegid()_ - возвращает эффективный идентификатор группы.  
* _setuid()_ - установка реального и эффективного идентификатора пользователя в значение _uid_.
* _seteuid()_ - установка эффективного идентификатора пользователя.  
* _setgid()_ - аналогично, установка реального и эффективного идентификатора группы.  
* _setegid()_ - установка эффективного идентификатора группы.  

#### Пользователи системы

Для обеспечения различных прав взаимодействия с ОС, введена концепция _пользователей системы_. Собственно пользователь - это объект обладающий определёнными правами на взаимодействие с ОС - права на исполнения различных программ, права на владение файлами и пр. Работа с ОС происходит только от лица зарегестрированного в ней пользователя. Чтобы войти в систему, требуется ввести имя пользователя и пароль, эти атрибуты позволяют защитить доступ к использованию тех или иных привелегий в ОС.  

В UNIX системах существует пользователь, обладающий неограниченными правами - _суперпользователь_ или _администратор системы_ (обычно имет имя ___root___).  

Каждый пользователь системы имеет уникальное имя (___login name___), которое взаимно-однозначно ассоциировано с его идентификатором - _идентификатором пользователя_ (___UID___). ОС оперирует как раз этими идентификаторами.  

Каждый пользователь является членом одной или нескольких _групп_ - списков пользователей, какждый из которых объединяет пользователей по определённой задаче в рамках ОС. Принадлежность к группе определяет для их членов дополнительные права. Каждая группа имеет уникальное среди других групп имя и также, как и в случае с пользователими, имеет свой уникальный идентификатор (___GID___).  

Таким образом, полный набор прав пользователя определяется идентификаторами _GID_ и _UID_.

Вся информация о пользователях хранится в файле __/etc/pswd__ (на самом деле она может хранится и в других местах, но здесь перечисляется основная). Это обычный текстовый файл, право на чтение которого имеют все пользователи, а право на запись - только _администратор системы_. В этом файле хранятся атрибуты пользователей, в т.ч. и пароли, но в зашифрованном виде. В некоторых ОС зашифрованные пароли хранятся в отдельном файле __/etc/shadow__, закрытым для чтения и записи обычным пользователям из соображений безопасности.

Информация о группах также хранится в отдельном файле __/etc/group__ и содержит в себе списки пользователей - членов той или иной группы.  

__атрибуты пользователей__

Как было указано ранее, файл __/etc/pswd__ содержит основную информацию о пользователе системы. На некоторых системах добавление нового пользователя может свестись к простому редактированию этого файла, посредством добавления новой записи. Однако, на большинстве систем такой способ может привести к неправильной регистрации пользователя, а иногда и к нарушению работы самой системы. Поэтому, обычно ОС предоставляют для регистрации и редактирования пользователей специальные утилиты.  

Тем не менее, основные атрибуты пользователей в виде соответствующих записей хранятся в файле __/etc/pswd__, поэтому расмотрим его структуру:

Каждая строка этого файла соотвествует записи с атрибутами отдельного пользователя. Эта строка имеет следующий формат:

_name:passwd-encod:UID:GID:comments:home-dir:shell_

Всего - 8 атибутов, разделённых двоеточием. Рассмотрим каждый из них подробнее:

* UID - идентификатор пользователя, внутреннее представление пользователя в системе. Пользователь с идентификатором UID=0 является _супер пользователем_.  
* GID - идентификатор первичной группы пользователя.  
* comments - обычно соответствует полному имени пользователя. Может содержать дополнительную информацию, например почту или номер телефона.  
* home-dir - домашний каталог пользователя. В нём пользователь оказывается при входе в систему. Обычно домашний каталог - это область файовой системы, где пользователь не имеет ограничений по правам.  
* shell - имя командного интерпретаора, которую UNIX запускает при входе пользователя в систему (например /bin/bash).

__реальный и эффективный идентификатор пользователя__

Вернёмся к теме процессов. Среда исполнения процесса включает в себя два параметра - _реальный_ и _эффективный_ идентификаторы пользователя. Реальный идентификатор пользователя соответствует идентификатору пользователя, который процесс запустил, а эффективный служит для определения прав доступа процесса к системным ресурсам, прежде всего - к ресурсам файловой системы. Т.е. фактически эффективный идентификатор соответствует привелегиям процесса по взаимодействию с системными ресурсами - редактированию файлов, запуску различных программ и пр.  

Обычно реальный идентификатор соответствует эффективному, но существуют системные вызовы, которые могут расширить привелегии процесса посредством изменение эффективного идентификатора дав ему права более привелегированного пользователя.  

__реальный и эффективный идентификатор группы__

Группа пользователей задаёт им отдельные привелегии. Реальный идентификатор группы соответствует первичному или текущему идентификатору группы пользователя, запустившего процесс. Эффективный - определяет привелегии процесса по взаимодействию с системными ресурсами на уровне группы пользователей. Эффективный идентификатор группы обыно соответствует реальному и его точно также можно поменять используя соответствующий системный вызов.  

#### Стандартная библиотека ввода/вывода

Для осуществления операций ввода/вывода на устройстве, операционная система предоставляет приложениям _интерфейс системных вызовов_ в виде ф-ций языка C, вызывая которые приложение могут обратиться к ядру операционной системы для проведения данных операций. Эти ф-ции являтся своего рода "обёртками" над непосредственными ф-циями ядра.

Однако этот интерфейс является довольно низкоуровневым и достаточно редко используется прораммистами. Предпочтение отдаётся ф-циям из _стандартной библиотеки_ языка C.

Стандартная библиотека ясыка C (libc.a или <span>libc.so<span>), которая на стадии связывания подключается автоматически, предоставляет ф-ции _буферезированного_ ввода-вывода т.е. ф-ции, которые используют буферы в оперативной памяти для промежуточного хранения считанных или записанных данных, для того, чтобы затем, используя один раз системный вызов подать эти данные на ввод непосредственно в пользоательскую структуру данных, или на вывод. Для использования этих ф-ций требуется включить в программу заголовочный файл <stdio.h> - это заголовочный файл _стандартной библиотеки ввода/вывода_.

Вместо использования файлового дескриптора, библиотека определяет указатель на специальную струкуру FILE, который называется _потоком_ или _файловым указателем_ (не путать с потоком исполнения).

Стандартные потоки ввода/вывода обозначаются следующими менами:

* __stdin__ - стандартный поток ввода
* __stdout__ - стандартный поток вывода
* __stderr__ - стандартный поток ошибок

Они определены следующим образом:

``` C
extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;
```

У данных потоков имеется прямое соответствие с системными файловыми дескрипторами:

|дескриптор|поток|описание|
|---|---|---|
|0|stdin|стандартный поток ввода, зарезервирован под ввод данных и команд пользователя ОС.|
|1|stdout|стандартный поток вывода, зарезервиованный под вывод данных.|
|2|stderr|стандартный поток ошибок, зарезервирован для вывода диагностических сообщений|

Потоки stdin и stdout можно перенаправить на другие структуры, итерпретируемые как объект FILE, при помощи команд '<' и '>' соответсвенно. Со стандартным потоком ошибок такое осуществить нельзя, перенаправление вывода программы при помощи команды '>' и создания конвееров '|' не повлияет на вывод stderr - он гарантированно попадёт пользователю.  

Это и отличает stderr от stdout. Это и позволяет разделять стандартный вывод программы от вывода дагностических сообщений и сообщений об ошибках.  

### Межпроцессное взаимодействие

#### Сигналы

Сигналы представляют из себя способ передачи от одного процесса к другому или от ядра ОС к процессу уведомления о возникновении определённого события. Сигналы можно рассматривать, как простейшую форму межпроцессного взаимодействия.  

Сигналы появились ещё в ранних версиях UNIX, но были реализованы ненадёжно. Возникал ряд проблем: сигнал мог быть утерян, также имелись сложности блокирования выполнения сигналов на время работы с критическими секциями кода. В версии _System V_ были внесены изменения, предоставлявшие ___надёжные___ (_reliable_) сигналы. В настоящее время интерфес надёжных сигналов регламентирует стандарт __POSIX.1__.  

Можно выделить три способа того, как процесс отреагирует на сигнал:

1. Сигнал может быть проигнорирован. Игнорировать сигналы вызванные аппаратной частью, например деление на 0 и обращение к недопустимой области памяти, не стоит, поскольку дальнейшие результаты работы процесса в котором это произошло будут непредсказуемы.  
<br>
2. Процесс может потребовать действие по умолчанию. Обычно, это в итоге сводится к завершению процесса.  
<br>
3. Процесс может перехватить сигнал и самостоятельно его обработать. Важно отметить, что некоторые сигналы нельзя ни перехватить, ни проигнорировать, например сигналы - _SIGKILL_ и _SIGSTOP_.  

Текущее действие процесса при получении сигнала называется ___диспозицией сигнала___.

Сигнал может быть отправлен процессу либо ядром ОС, либо другим процессом при помощи системного вызова _kill(2)_:  

``` C
#include <sys/types.h>
#include <signal.h>

int kill(pid_t pid, int sig);
```
Аргумент _sig_ соответствует номеру сигнала, а _pid_ - идентификатору процесса, которому данный сигнал отправляется.  

При помощи системного вызова _kill(2)_ процесс может послать сигнал как самому себе, так и другому процессу или даже группе процессов. Во втором случае, процесс, отправлющий сигнал должен иметь те же реальный и эффективный идентификаторы, что и те процессы, которым сигнал отправляется.  

Вышеупомянутое ограничение не распространяется на процессы, обладающие привелегиями _суперпользователя_.  

# POSIX THREAD LIBRARY

### Введение

#### Потоки

Для исполнения программ в UNIX-системах используются процессы. Каждый процесс является совего рода окружением для исполняемой программы, содержащий собственное виртуальное адресное пр-во и другие ресурсы. Для каждого процесса создаётся иллюзия последовательного исполнения. Взаимодействие процессов возможно только при использованиии системных вызовов, напрямую процесс не может обратиться к данным другого.

Существует ряд задач, требующих некой параллельной обработки данных. Традиционным решением в UNIX было бы использование нескольких параллельно работающих и взаимодействующих между собой процессов. Однако, для решения подобных задач использование этих средств является неоптимальным, а иногда и вовсе неприемлемым. Также была потребность переноса приложений с ОС, допускавших несколько нитей исполнения в рамках одного процесса, на UNIX.  

По этим причинам, в UNIX было введено понятие _нити_ или _потока_ (_thread_). 
* __поток__ - единица планирования в рамках одного процесса.  

Нити процесса разделяют одно общее адресное пр-во, но планируются независимо. Иллюзия последовательного исполнения создаётся именно для нити, а не для процесса в целом.

#### Сборка приложений с использованием POSIX THREAD LIBRARY
Для GCC компилятора:
``` shell
gcc -o labn -threads -lpthread labn.c 
```

или

``` shell
gcc -o labn -pthread -lpthread labn.c 
```


Для Sun Studio 11

``` shell
cc -o labn -mt -lpthread labn.c 
```

При указании ключа _-mt_ или _-pthread_ (_-threads_) при компиляции и сборке, переменная _errno_ становится макроопределением, позволяющее каждому потоку иметь своё собственное _errno_. Значение данного макроопределения можно переинициализировать или же просто использовать, как если бы оно было обычной переменной.

Ключ _-lpthread_ интерпретируется компилятором следующим образом. У данного ключа параметром указана строка pthread, в начало к нему добавляется строка lib, в конце .so или .a, в зависимости от типа сборки - статической или динамической. В результате получается строка libpthread.so, соответсвующая имени библиотеки _posix threads_

#### Реализация многопоточности

Стандарт POSIX допускает различные подходы к реализации многопоточности. Рассмотрим три основных:  

* Нити в пределах одного процесса (в пользовательском адресном пр-ве) переключаются собственным _пользовательским планировщиком_.  

* Переключение между нитями осуществляется _системным планировщиком_, так же, как и при переключении между процессами.  

* Гибридная реализация, при которой каждому процессу выделяется некоторое кол-во системных нитей, при этом процесс также имеет свой собственный пользовательский планировщик в пользовательском адресном пр-ве.  
     
_Примечание:_ в данном контексте _пользовательской нитью_ является нить, планируемая _пользовательским планировщиком_, а _системной нитью_ - нить, планируемая системным планировщиком соответственно. В большинстве UNIX-системах в т.ч. в Solaris системные нити называются _LWP - Light Weight Process_.

__использование пользовательского планировщика__

Достоинством данного варианта является то, что он может быть реализован без изменений ядра системы. Когда системный планировщик передаёт планирование процессора на какой-то процесс, пользовательский планировщик этого процесса может решить, какой из пользовательских нитей передать управление.  

Однако, при практическом применении такого планировщика возникает серьёзная проблема. Если одна из нитей процесса выполнит блокирующийся системный вызов, то тогда заблокируется весь процесс. Решение данной проблемы потребует произвести серьёзные изменения в ядре операционной системы, что в итоге сводит на нет главное достоинство пользовательского планировщика.

__использование системного планировщика__

Ядро типичной ОС уже имеет системный планировщик, который переключает управление между процессами. Переделать этот планировщик для того, чтобы он также мог переключать несколько нитей одного процесса относительно нетрудно. Возможны два способа это сделать:
     
1. Нить является подчинённой, по отношению к процессу сущностью. Идентификатор нити состоит из идентификатора процесса и собственного идентификатора нити, уникального в рамках данного процесса. (А вчём подход то??) Большинство UNIX-систем использует именно такой подход, в т.ч. и Solaris 10.

2. Нить является сущностью того же уровня, что и процесс. __?__

Поскольку ОС с данным подходом реализации многопоточности (в частности Solaris 10 и Linux) используют именно системные нити, то каждому потоку POSIX Thread API соответствует отдельный LWP.

### Описание библиотечных функций для Solaris 10 и концепций POSIX THREAD LIBRARY

* __pthread_create__  - функция создания новой нити в текущем процессе. [Документация.](https://docs.oracle.com/cd/E26505_01/html/816-5168/pthread-create-3c.html#scrolltoc)  

__сигнатура:__
``` C
#include <pthread.h> 

int pthread_create(pthread_t *restrict thread,
     const pthread_attr_t *restrict attr,
     void *(*start_routine)(void*), void *restrict arg);
```
__описание работы:__
Функция создаёт новую нить в текущем процессе с атрибутами указанными параметром _attr_. Если данный параметр равен _NULL_ используются атрибуты по умолчанию. При последующей модификации атрибутов указанных в _attr_ атрибуты самой нити не модифицируются.  

После создания поток исполняет функцию _start_routine_ с параметром, указанным в _arg_. В случае, если данная функции возвращает результат, то это имеет тот же механизм работы, что и вызов _pthread_exit()_ с возвращаемым значением в качестве статуса выхода.  

Однако, для потока, в котором исполняется _main()_ ситуация отличается:
Когда происходит возврат из функции _main()_ это эквивалентно вызову _exit()_ с возвращаемым значением _main()_ в качестве кода выхода.  

В случае успеха, создаётся новый поток, как описано выше и _pthread_create()_ возвращает 0. В противном случае, нового потока не создаётся, содержание данных, на которые указывает аргумент _thread_ не определено. Также функция возвращает код ошибки:  

```
     EAGAIN - системе не хватает ресурсов для создания нового потока, или было превышенно 
     установленное системой максимальное кол-во потоков в процессе.

     EINVAL - значение attr некорректно.

     EPERM - у вызывающего потока нет необходимого разрешения для установки 
     необходимых параметров планирования или политики планирования.
```

---

* __pthread_exit()__ - данная ф-ция завершает исполнение потока. [Документация.](https://docs.oracle.com/cd/E26505_01/html/816-5168/pthread-exit-3c.html#scrolltoc)

__сигнатура:__

``` C
#include <pthread.h>

void pthread_exit(void *value_ptr);
```
Если атрибут потока _detachstate_ имеет значение PTHREAD_CREATE_JOINABLE, статус выхода, указанный параметром _value_ptr_ становится доступным при вызове _pthread_join()_ к текущему потоку.  

Все обработчики прерывания после вызова _pthread_exit()_ изымаются из стека и исполняются в порядке _FILO_. (Про обработчики прерывания нити будет написано позже.) По завершении исполнения всех обработчиков прерывания, если поток имеет _Thread Specific Data_, то соответствующие деструкторы для её освобождения также вызываются, но порядок их вызова неопределён. Остальные ресурсы нити - _стек_ и _дескриптор_ освобождаются согласно значению атрибута _detachstate_  (см. атрибуты нити).  

Неявный вызов _pthread_exit()_ происходит, когда в поток, отличный от _main_, возвращается из ф-ции, с которой он создавался, посредством оператора _return_. В данном случае, возвращаемое знаение ф-ции можно считать статусом выхода в _pthread_exit()_.  

Отдельно стоит отметить разницу использования _return_ и _pthread_exit()_ в потоке _main_. При вызове оператора _return_ в _main_ происходит неявный вызов системного вызова _exit(2)_, завершающего процесс и, как следствие, все потоки в нём. В случае, если в _main_ был вызван _pthread_exit()_, то завершится только этот поток, остальные продолжат работу, пока они все не завершаться, либо пока не будут вызваны другие ф-ции, завершающие процесс.  

__возвращаемые значения:__

Данная ф-ция не может вернуться к вызыващему её потоку, поскольку она его завершает.

__коды ошибок:__
```
ошибки не определены
```

---

* __pthread_join()__ - ф-ция ожидания завершения нити.

__сигнатура:__
``` C
#include <pthread.h>

int pthread_join(pthread_t thread, void **status);
```

Данная ф-ция приостанавливает работу вызывающей нити, до тех пор, пока целевая нить, указанная параметром _thread_ не завершиться. Целевой поток должен быть чатью текущего процесса и не может иметь значение атрибута _detachstate_ равное _PTHREAD_CREATE_DETACHED_.

Если несколько потоков ожидает завершение целевой нити через _pthread_join()_, то когда данная нить завершиться один из потоков вернётся из _pthread_join()_ успешно, а другие с ошибкой _ESRCH_.

В случае успешного завершения данной ф-ции параметр _status_, если он не равен _NULL_, будет указывать на область памяти, куда было записано возвращаемое значение из _start_routine_.  

Стоит отметить, что по возвращении из ф-ции _pthread_join()_ нить, к которой она была вызвана перестанет существовать, соответственно все связанные с ней ресурсы к этому времени будут освобождены. По этой причине нельзя передавать в качестве аргумента ф-ции _pthread_exit(3C)_ указатель на облаcть памяти стека нити, к которой мы производим _pthread_join()_, ведь в таком случае мы получим висячую ссылку.  

__возвращаемые значения:__

_pthread_join()_ возвращает 0, в случае успеха и код ошибки, в противном случае.

__коды ошибок:__

```
EDEADLK - поток ожидает завершение самого себя, тем самым порождая мёртвую блокировку.

EINVAL - целевой поток, имеет значение атрибута detachstate равное PTHREAD_CREATE_DETACHED.

ESRCH - указан некорректный идентификатор потока thread.
```

---

__атрибуты нити:__
При создании нити можно указать ей блок атрибутов при помощи параметра _attr_. Данный блок представляет из себя структуру _pthread_attr_t_. Ниже приведён список с описанием основных атрибутов нити. Кроме этих атрибутов структура _pthread_attr_t_  содержит некоторые другие (например _cancelation state_ и _cancelation type_, которые будут рассмотрены позже). 

Для каждого атрибута из блока _pthread_attr_t_ определены ф-ции установки и взятия значения вида (get/set) - _pthread_attr_set$AttributeName$_ и _pthread_attr_get$AttributeName$_. Изменение атрибутов в структуре _pthread_attr_t_ не повлияет на атрибуты нитей, которые были уже созданы с ней. Таким образом, одну и ту же структуру _pthread_attr_t_ можно использовать для инициализации нескольких нитей.

Некоторые атрибуты самой нити могут быть модифицированны после её создания, наример __detachstate__ и __priority__.

* __scope (область действия)__ - допустимые значения:  _PTHREAD_SCOPE_SYSTEM_ и _PTHREAD_SCOPE_PROCESS_.
     <br/>

     * _PTHREAD_SCOPE_SYSTEM_ - нить планируется системным планировщиком и соревнуется за системные ресурсы с другими процессами. 
     <br/>

     * _PTHREAD_SCOPE_PROCESS_ - нить планируется пользовательским планировщиком и считается частью своего роцесса (__по умолчанию__ для Solaris). 
     <br/>
     
     Solaris и Linux являются ОС, в которых многопоточность имеет реализацию через _системный планировщик_ и каждый поток соответствует собственному _LWP_, поэтому данный атрибут не имеет практического значения. В Linux данный атрибут может быть равен только _PTHREAD_SCOPE_SYSTEM_, в Solaris 10 таких ограничений нет, но атрибут всё-равно бесполезен. В таком случае, правильнее было бы указать _PTHREAD_SCOPE_SYSTEM_ как значение по умолчанию для Solaris, но имеем, что имеем.   
<br/>

* __detachstate (присоединён/отсоединён)__ - Допустимые значения: _PTHREAD_CREATE_JOINABLE_ и _PTHREAD_CREATE_DETACHED_.
     <br/>
     * _PTHREAD_CREATE_DETACHED_  - ресурсы нити будут освобождены сразу после её завершения.
     <br/>
     * _PTHREAD_CREATE_JOINABLE_ - ресурсы нити будут освобождены после того, как другая нить вызовет _pthread_join()_ к ней.
<br/>

* __stacksize (размер стека)__ - допустимые значения: 0 или размер стека в байтах. 0 означает, что расмер стека определяется операционой системой. В Solaris 10 на 32-битной архитектуре стек выделяется размером __1mb__, на 64-битной - __2mb__. Минимальный размер стека, который можно выделить нити, определён константой _PTHREAD_STACK_MIN_ в <pthread.h>.
<br/>

* __stack_addr (адрес начала стека)__ - Допустимые значения: NULL(адрес определяется ОС) или указатель на область памяти для размещения стека нити. Не рекомендуется выделять память под стек самостоятельно, поскольку, в таком случае, система не будет освобождать эту память автоматически, это должен реализовать программист __?__.
<br/>

* __Concurrency__ (степень параллелизма) - допустимые значения: положительные целые числа. В системах с гибридной реализацией планирования нитей, данной значение с определённым приближением соответствует кол-ву системных нитей, создаваемых системой для текущего процесса.
В Solaris 10 данный атриут игнорируется и нужен только для совместимости со стандартом POSIX. 
<br/>

* __Schedpolicy__ (политика планирования) - допустимые значения: Допустимые значения – SCHED_FIFO, SCHED_RR и SCHED_OTHER.
     <br/>

     * SCHED_FIFO - планирование нитей осуществляется в порядке линейной очереди. Также, при данной политике планирования, после получения управления нить отдаст его только, когда заблокируется на примитиве синхронизации.  
     <br/>

     * RR - планирование нитей осуществляется в порядке кольцевой очереди. Нить, получившая управление отдаёт его по истечении кванта времени, либо до момента явной отдачи управления. При отдаче управления нить помещается в конец очереди.  
     <br/>

     * SCHED_OTHER - данное значнение соответствует системной политке планирования. Нить использует фиксированные приоритеты на исполнения, задаваемые операционной системой. Используется вытесняющая многозадачность, т.е. решения о переключении исполнения с одной нити на другую принимаются по истечении некоторого кванта времени и исходя из приоритетов нити.  

| атрибут | значение по умолчанию | описание |
| ----| ---| ---|
| scope | PTHREAD_SCOPE_PROCESS | Нить планируется пользовательским планировщиком. В Solaris 9 и последующих версиях Solaris этот параметр не имеет практического значения|
| detachstate | PTHREAD_CREATE_JOINABLE | нить создаётся присоединённой |
|stackaddr | NULL | адрес начала стека нити определяется системой | 
| stacksize | 0 | размер стека нити определяется системой | 
| priority | 0 | нить имеет приоритет 0 |
| inheritsched | PTHREAD_EXPLICIT_SCHED | Нить не наследует приоритет у родительской нити |
| schedpolicy | SCHED_OTHER | Нить использует фиксированные приоритеты, задаваемые ОС. Используется вытесняющая многозадачность (нить исполняется, пока не будет вытеснена другой нитью или не заблокируется на примитиве синхронизации) |

__ресурсы нити:__

Выше упоминались некие "ресурсы нити", которые в зависимости от значения атрибута detachstate освобождаются при разных условиях. Это следующие ресурсы:

* __стек нити__ - область стека процесса нити, который выделен под её работу. Адресные пр-ва стеков отдельных нитей между собой не пересекаются.  

* __Thread Local Data__ (или __Thread Specific Data__) - глобальные данные локальные для каждого потока. Существуют способы выделения глобальных данных в сегментах DATA и BSS, локально для каждой нити, чтобы только нить-хозяин имела к ним доступ. Концепция _thread local storage_ является совокупностью таких способов. В частности, при компиляции многопоточной программы с ключём _-mt_, для каждого потока выделяется собственная область памяти под значение _errno_, это пример использования thread local data. 
* __дескриптор нити__ - собственно структура, которая идентифицируется значением объекта _pthread_t_, содержащая всю необходимую информацию о нити: значения атрибутов нити, управляющая информация для ядра ОС __?__.  

Данные ресурсы освобождаются согласно значению атрибута _detachstate_, за исключением _Thread Local Data_, деструкторы которого вызываются при завершении нити, допустим, при вызове _pthread_exit(3C)_ или в момент прерывания нити. Более подробно про процесс освобождения ресурсов _Thread Local Data_ можно посмотреть непосредственно в документации к _pthread_exit(3C)_  и _pthread_cancel(3C)_.  

## Прерывание нити

Здесь описываются концепции прерывания нити определённые в POSIX thread. Прерывание позволяет потоку осуществить прерывание другого потока в рамках того же процесса. Это может потребоваться, например, при параллельном поиске решения задачи несколькими потоками. Когда один поток нашёл ответ и после осуществляет прерывание других.  

__Функции__:
| имя | описание |
|---|---|
| pthread_cancel() | прерывание исполнения потока |
| pthread_setcancelstate() | установка атрибута потока ___cancel state___ |
| pthread_setcanceltype() | установка атрибута потока ___cancel type___ |
| pthread_testcancel() | установка ___точки прерывания___ у текущего потока|
| pthread_cleanup_push() | добавление функции обработчика прерывания |
| pthread_cleanup_pop() | изымание функции обработчика прерывания |

* __pthread_cancel()__ - данная функция принудительно завершает нить. Если точнее, делает запрос нити на прерывание. [Документация](https://docs.oracle.com/cd/E26505_01/html/816-5168/pthread-cancel-3c.html#scrolltoc).

__сигнатура:__

``` C
#include <pthread.h> 

int pthread_cancel(pthread_t target_thread);
```

В зависимости от св-в нити и других обстоятельств она может продолжить своё исполнение на некоторое время после вызова _pthread_cancel()_ к ней. Механизм прерывания контролируется атрибутами _cancellation state_ и _cancellation type_.  

Когда прерывание нити активированно происходит следующее: вызываются _обработчики прерывания_ (про которые будет написано позже), __после этого__ вызываются деструкторы _thread specific data_. По возврату из вызова последнего деструктора, нить считается завершённой.    

В случае успеха, функция возвращает 0, в противном случае - код ошибки.    

__Коды ошибок:__
```
ESRCH - некорректное значение идентефикатора потока - target_thread.
```
----
* __pthread_setcancelstate()__ - устанавливает значение атрибута _cancellation state_ в текущем потоке, делает это _атомарно_. Это значение определяет разрешено ли прерывание нити в принцыпе. [Документация](https://docs.oracle.com/cd/E26505_01/html/816-5168/pthread-setcancelstate-3c.html#scrolltoc)  

__сигнатура:__
``` C
#include <pthread.h>

int pthread_setcancelstate(int state, int *oldstate);
```
Параметр _state_ - значение, которое будет установлено в атрибут _cancellation state_, параметр _old state_ служит для получения старого значения _cancellation state_. Если _old state_ не равен NULL, то в область памяти, на которую указывает _old state_ будет помещено предыдущее значение _cancellation state_.  

Параметр _state_ может принимать следующие значения:

```
PTHREAD_CANCEL_ENABLE - прерывание нити разрешено. (По-умолчанию)

PTHREAAD_CANCEL_DISABLE - прерывание нити запрещено.
```
__Возвращаемые значения:__

В случае успеха, функция _pthread_setcancelstate()_ вернёт 0. В противном случае - код ошибки.

__Коды ошибок:__

```
EINVAL - значение state не является одним из предложенных - PTHREAD_CANCEL_ENABLE, PTHREAAD_CANCEL_DISABLE.  
```
---
* __pthread_setcanceltype()__ - установка атрибута _cancellation type_ текущего потока, который определяет в каких точках программы поток может быть прерван.  

__сигнатура:__

``` C
#include <pthread.h>

int pthread_setcanceltype(int type, int *oldtype);
```

Параметры _type_ и _oldtype_ - значение, которое будет установлено в атрибут _cancelation type_ и ссылка на область памяти, в которую будет помещено старое значение _cancelation type_ соответсвенно. Всё аналогично ф-ции _pthread_setcancelstate()_.

Параметр _type_ может принимать следующие значения:
```
PTHREAD_CANCEL_DEFERRED - когда прерывание нити разрешено (cancelation state=PTHREAD_CANCEL_ENABLE) нить получает сообщение о 
прерывании и, собственно, ожидает прерывания по достижении точки отмены (cancelation point). Если прерывание запрещено, 
то все сообщения о прерывании остаются в ожидании.
(По-умолчанию)

PTHREAD_CANCEL_ASYNCHRONOUS - если прерывание нити разрешено, то оно происходит как можно скорее. Если прерывание запрещено,
то сообщения о прерывании остаются в ожидании. Когда прерывание вновь станет разрешено, все накопренные запросы на отмену
выполнятся немедленно.
```

__Возвращаемые значения:__

В случае успеха, функция _pthread_setcanceltype()_ вернёт 0. В противном случае - код ошибки.

__Коды ошибок:__

```
EINVAL - значение type не является одним из предложенных - PTHREAD_CANCEL_DEFERRED, PTHREAD_CANCEL_ASYNCHRONOUS.  
```

Для упрощения понимания контроля прерывания, ниже приведена таблица где каждой паре значений _cancelation type_ и _cancelation state_ соответствует описание того, как происходит прерыание нити:

|Cancelation Type \ Cancelation State|PTHREAD_CANCEL_ENABLE|PTHREAAD_CANCEL_DISABLE|
|--|--|--|
|__PTHREAD_CANCEL_DEFERRED__|Прерывание происходит, когда нить ожидает прерывания по достижении точки отмены. (По-умолчанию)|Все запросы на прерывание нити остаются в ожидании.|
|__PTHREAD_CANCEL_ASYNCHRONOUS__|Вызов _pthread_cancel()_ осуществляет прерывание нити, как можно скорее.|Все запросы на прерывание остаются в ожидании. Когда прерывание снова будет доступно, все ожидающие запросы выполнятся немедленно.|

#### Точки отмены

Операционной системой определены так называемые _точки отмены_ (_cancelation points_), по достижении которых, может происходить прерывание нити. Это некоторые библиотечные ф-ции и системные вызовы, список которых можно посмотреть [здесь](https://docs.oracle.com/cd/E26505_01/html/816-5175/cancellation-5.html#REFMAN5cancellation-5). Прерывание нити будет происходить после вызова ф-ции, определённой как точка отмены, и до её возврата.  

Как правило любая ф-ция, вызов которой может потребовать длительного ожидания потока, должна являться точкой отмены. Такие ф-ции должны проверять ожидающие запросы на прерывание нити, перед тем, как заблокировать её на неопределённый срок. Собственно, такая проверка реализована во всех ф-циях, которые являются точками прерывания. Более того, большинство ф-ций и системных вызовов, указанных в качестве точек прерывания подразумевают блокирование нити, на неопределённый срок, до тех пор, пока реализуемая ими операция не будет выполнена.  

Также, программист может указать точки прерывания явно, посредством вызова ф-ции _pthread_test_cancel()_.  

* __pthread_testcancel()__ - устанавливает явную точку отмены.

__сигнатура:__
``` C
#include <pthread.h>

void pthread_testcancel(void);
```

__Возвращаемые значения:__

Данная ф-ция возвращает _void_.

__Коды ошибок:__

Не возвращает ошибок.

#### Обработчики прерывания

При завершении нити может возникнуть необходимость освободить некоторые ресурсы, вернуть данные в соглассованное состояние или провести какие-то другие манипуляции, которые необходимы именно перед завершением нити.

Для таких целей можно добавить _обработчики прерывания_. Функции, которые будут вызваны нитью, перед её фактическим завершением в процессе прерывания. Данные обработчики, по сути, являются обычными функциями, объединённых в стековую структуру, над которой можно производить операции добавления и извлечения.  

Обработчики прерывания необходимо добавлять до точек отмены. В случае асинхронного прерывания - до момента, где это может произойти.  

* __pthread_cleanup_push()__ - добавляет функцию обработки прерывания в стек (имеется в виду не стек процесса, а отдельная структура для каждой нити) вызывающей нити.

__сигнатура:__
``` C
#include <pthread.h>

void pthread_cleanup_push(void (*handler) (void *), void *arg);
````

Аргумент _handler_ - это, собственно, вызываемая функция-обработчик, _arg_ - её аргумент.  

Когда поток завершается или прерывается и стек обработчиков не пуст, они извлекаются и выполняются в порядке LIFO, т.е. в порядке извлечения элементов из стека.

__Возвращаемые значения:__

Ф-ция ничего не возвращает.

__Коды ошибок:__

Не возвращает ошибок.

---

* __pthread_cleanu_pop()__ - извлекает ф-цию обработчик с вершины стека и, в зависимости от аргумента, исполняет её.  

__сигнатура:__

``` C
#include <pthread.h>

void pthread_cleanup_pop(int execute);
```

Если аргумент _execute_ не нулевой, то происходит извлечение ф-ции обработчика с вершины стека и её исполнение. Если _execute_ = 0, то ф-ция извлекается с вершины стека без последующего исполнения.  

__Возвращаемые значения:__

Ф-ция ничего не возвращает.  

__Коды ошибок:__

Не возвращает ошибок.  

Ф-ции _pthread_cleanup_push()_ и _pthread_cleanup_pop()_ реализованы в виде макрокоманд. Вызов _pthread_cleanup_push()_ должен сопровождаться парным вызовом _pthread_cleanup_pop()_ в одной и той же лексической области:

``` C
void *print_text() {
  pthread_cleanup_push(cleanup_handler, NULL);  // push cleanup routine to the stack

  while (1) {
    pthread_testcancel();
    printf("%s\n", printing_text);
    usleep(PRINT_DELTA_TIME);
  }
  pthread_cleanup_pop(1);

  return NULL;
}
```

Это связано с тем, что макрос _pthread_cleanup_push()_ начинается токеном '{', а _pthread_cleanup_pop()_ завершается токеном '}', поэтому, попытка вызвать любую из этих команд без соответсвующей пары приведёт к ошибке компиляции.  

Также важно отметить, что результат работы операторов __return__, __break__, __continue__, __goto__, для покидания блока кода, ограниченного макросами _pthread_cleanup_push()_ и _pthread_cleanup_pop()_ __неопределён__.

#### Потокобезопасность

Термин _потокобезопасность_ или _thread-safe_ чаще всего применяется к ф-циям и библиотекам вцелом и означает гарантию безопасности их работы в условиях многопоточности. 

Что подразумевает под собой безопасность работы? Дело в том, что многие библиотечные ф-ции в своей реализации используют различные внутренние переменные и структуры данных. Для нормальной работы таких ф-ций от вызова к вызову их внутренние переменные должны удовлетворять определённым требованиям, т.е. находиться в согласованном состоянии. В процессе работы ф-ций эта согласованность так или иначе может нарушаться, но по их завершению   обязана восстанавливаться.

В условиях многопоточности возникает следующая проблема. Одна нить работает с библиотечной ф-цией, которая использует какие-то внутренние структуры данных, другая нить тоже вызывает какую-нибудь ф-цию, которая полагается на целостность этой внутренней структуры. Очень часто, такая работа будет иметь некорректный результат, потому что первая нить вероятно нарушит целостность общей структуры, в то время как вторая при своей работе на эту целостность полагается.

Для решения этой проблемы _thread-safe_ ф-ции должны защищать разделяемые внутренние структуры данных различными _примитивами синхронизации_, о которых будет изложено позже. 

Библиотеки и функции имеют уровни поддержки многопоточности, описываемые атрибутом __MT-Level__. Его возможные значения и их смысл описаны ниже, а также в [официальной документации Oracle.](https://docs.oracle.com/cd/E26505_01/html/816-5175/attributes-5.html#scrolltoc)  

* _Safe_ - данный уровень обозначает безопасное использование ф-ции из нескольких потоков. Однако, требуется учитывать тот факт, что вызов такой "безопасной" ф-ции может изменить глобальные данные, что повлияет на работу всех потоков. Например, закрытие файла одним из потоков посредством системного вызова _close(2)_, в то время, как остальные потоки с этим файлом работают, может привести к нежелательным последствиям с точки зрения корректности работы программы. Хотя сама ф-ция является _thread-safe_: согласованность внутреннего состояния стандартной библиотеки никак нарушена не будет, при вызове этой ф-ции в условиях многопоточности.
<br/>

* _MT-Safe_ - ф-ция или библиотека полностью подготовлена для использования в условиях многопоточности. Её локальные данные защищены примитивами синхронизации. Также, такая библиотека или ф-ция обеспечивает разумный уровень параллелизма, т.е. не позволяет нитям удерживать примитивы синхронизации дольше, чем это необходимо. В качестве примера отличия _Safe_ библиотеки от _MT-Safe_ можно привести два варианта реализации: библиотека целиком защищена монитором, т.е. в данный момент времени работать с ней может только один поток, такая библиотека будет являться _Safe_; другой вариант, это, когда ф-ции библиотеки могут одновременно использовать несколько потоков, а её внутренние структуры данных защищены необходимыми примитивами синхронизации, таким образом, обеспечивается параллелизм использования, и такая библиотека будет уже являться _MT-Safe_.

Отдельно выделены уровни безопасности прерывания _Asynchronous-Cancel-Safe_ и _Deferred-Cancel-Safe_, о которых написано ниже.  

#### Безопасность прерывания

Во время прерывания потока возможна сетуация, когда используемые потоком ресурсы остаются в несогласованном состоянии. К примеру, прерывание может произойти в момент, когда ресурсы, используемой потоком динамической памяти не успели освободить, или когда поток не разблокировал захваченные примитивы синхронизации. В подобных ситуациях, если стек обработчиков прерывания потока не содержит ф-ций, вызов которых в соответствующем порядке не приводит используемые ресурсы в согласованное состояние, то тогда приложение/ф-ция/библиотека в контексте которой всё это происходит является ___небезопасной для прерывания___.  

Все приложения, в коде которых имеются вызовы _pthread_cancel()_ должны учитывать, что эти вызовы должны исполняться в ___безопасной для прерывания___ среде.  

Для характеристики безопасности прерывания в атрибуте MT-Level выделены отдельные значения - _Asynchronous-Cancel-Safe_ и _Deferred-Cancel-Safe_. Которые означают, что ф-ция/библиотека безопасна для __асинхронного__ прерывания (_PTHREAD_CANCEL_ASYNCHRONOUS_) и для __отложенного__ прерывания (_PTHREAD_CANCEL_DEFERRED_) соответственно.  

Поскольку при отложенном прерывании прерывание нити происходит только в ф-циях, являющихся точками отмены, то никаких проблем с несогласованностью разделямых данных возникнуть не может, обработка прерывания внутри этих ф-ций это гарантирует. Однако, если вы разрабатываете собственную библиотеку, то ваша реализация должна гарантировать, что когда нить будет прервана в той или иной точке отмены ресурсы библиотеки остануться в согласованном состоянии, что может быть обеспечено посредством добавления соответствующих обработчиков отмены.  

Другое дело, когда нить работает в режиме асинхронного прерывания. Если в документации __явно__ не указано, что библиотечная ф-ция является _Asynchronous-Cancel-Safe_, то считается, что она является небезопасной при использовании в режиме асинхронного прерывания.  
### Проблемы конкуренции

В многопоточной среде возможна ситуация когда несколько потоков обращаются к одному и тому же ресурсу. Каждый из потоков может делать с этим ресурсум какие-то манипуляции, не задумываясь о том, что проделанные им изменения, повлияют на работу других потоков, когда они к этому ресурсу будут обращаться.    

Проблемы нет, если доступ к этому ресурсу у потоков строго последовательный, проблема возникает тогда, когда во время проведения потоком какого-то набора операций над ресурсом в это же самое время другие потоки могут этот самый ресурс изменить или просто обратиться к его значению.  

Рассмотрим следующий сценарий работы. Предположим один поток выполняет над ресурсом какой-то набор операций и не предполагает, что во время этого, значение ресурса будет меняться со стороны. Тогда, работа потока будет иметь некорректный результат, поскольку последовательность промежуточных результатов была нарушена со стороны. Ещё возможен следующий сценарий. Пусть два потока выполняют над ресурсом набор операций. И один из потоков предполагает, что он обратиться к ресурсу, когда второй завершит свой набор операций над ним. В таком случае, возможна ситуация, что второй поток ещё не завершил свой набор операций, а первый уже обратился к значению ресурса. Тогда, результат работы первого потока будет некорректен, поскольку тот использовал старое значение ресурса.  

Теперь, конкретный пример. Предположим мы хотим реализовать последовательное инкрементирование целочисленной переменной двумя потоками. Сценарий работы нашего алгоритма может быть следующий: поток __A__ копирует значение переменной в регистр, производит над значением в регистре операцию инкрементирования, в результате получает __6__. В это же время, поток __B__ также копирует значение переменной и производит операцию инкрементирования, до того, как поток __A__ успел сохранить свой результат. Потом, поток __A__ сохраняет свой результат в переменную, затем, то же самое делает и поток __B__. По итогу мы имеем, что значение нашей переменной равно __6__, а не __7__, которое мы расчитывали получить.

#### Примитивы синхронизации

Тут следует ввести термин - __разделяемый ресурс__.

* __Разделяемый ресурс__ - ресурс, к которому возможен совместный доступ со стороны нескольких потоков или процессов.

Ресурс в данном случае является абстрактным понятием, этим может быть любая вещь, которую используют потоки. Это могут быть файлы, данные, вызовы ф-ции и т.д.  

Реализация корректного многопоточного доступа к разделяемым ресурсам решается на практике главным образом за счёт концепции __критических секций__ и взаимоисключающего доступа к ним. Дадим определение критической секции.

* __критическая секция__ - участок кода, при вхождение в который, поток полагается на целостность разделяемого ресурса, или же нарушает эту целостность.

Под _целостностью_ или _согласованностью_ подразумевается соответствие ресурса некоему состоянию, которое является допустимым при обращении потока к этому ресурсу.

Взаимоисключающий доступ к критической секции означает, что в один момент времени внутри секции может находиться не более одного потока.

Для того, чтобы реализовать взаимоисключающий доступ к критической секции невозможно использовать простую флаговую переменную, поскольку последовательность операций проверки и установки флаговой переменной сама по себе является критической секцией. Существуют алгоритмы реализации взаимоисключающего доступа при помощи нескольких флаговых переменных, например [алгоритм Деккера](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%94%D0%B5%D0%BA%D0%BA%D0%B5%D1%80%D0%B0). Однако, такие алгоритмы плохо масштабируются на произвольное кол-во потоков, поэтому в многопоточном программировании практически не применяются.  

В современных операционных системах для реализации корректного многопоточного доступа к разделяемым ресурсам используются более сложные _примитивы синхронизации_ (под _примитивом_ подразумевается тип данных, над которым определён фиксированный набор операций). Которые реализуют проверку флага и засыпание, пробуждение и установку флага, сброс флага и пробуждение другой нити, как __атомарные операции__. Т.е. те операции, которые всегда выполняются полностью и выполняются только одним потоком в данный момент времени.  

#### Мьютекс

Одним из таких примитивов синхронизации является __мьютекс__ от английского _mutual exclusion_ - взаимное исключение. У мьютеса может быть два состояния _свободен_ и _захвачен_. И определены две соответствующие операции - _lock_ (блокировка) и _unlock_ (снятие блокировки). Если нить попытается заблокировать захваченный мьютекс, то это приведёт к её засыпанию (блокировке на мьютексе). Блокировка свободного мьютекса приведёт его в захваченное состояние. Операция освобождения свободного мьютекса является недопустимой (в програмных реализациях это приводит к ошибке). Освобождение занятого мьютекса переведёт мьютекс в свободное состояние, если в этот момент на мьютексе были заблокированны другие нити, то одна из них просыпается и захватывает мьютекс.  

Согласно данной семантики операций над мьютексом, захват и освобождение мьютекса производятся одной и той же нитью, поэтому можно говорить, что у мьютекса есть _владелец_, т.е. тот поток, который последним его заблокировал и ещё не снял блокировку.  Наличие потока-владельца является главной особенностью мьютекса.  

Мьютекс имеет очевидное применение для решения задачи взаимоисключения. С каждым разделяемым ресурсом мы связываем мьютекс. На входе критической секции этого ресурса нить мьютекс захватывает, а на выходе освобождает.  

#### Семафор

Примитив синхронизации, реализованный на базе целочисленного счётчика, принимающего неотрицательные значения. Семафор поддерживает атомарные операции инкрементирования и декрементирования счётчика. Декрементирование счётчика со значением 0 является блокирующимся, т.е. поток пытающийся это сделать засыпает (блокируется) до тех пор, пока значение счётчика снова не станет больше нуля.

Семафоры можно использовать, как счётчики кол-ва свободных ресурсов. Для получения ресурса, поток производит операцию декрементирования счётчика семафора и получает свой ресурс. Возвращая ресурс после работы, поток инкрементирует счётчик семафора. Тем самым, если свободных ресурсов нет, потоки, пытающиеся их получить, засыпают.

Также, семафоры можно использовать для защиты критических секций. Если взять начальное значение счётчика семафора за 1, при входе в критическую секцию дикрементировать значение счётчика, а при выходе инкрементировать, то тогда мы получим необходимый нам взаимоисключающий доступ к критической секции.

#### Отличия

Однако, у семафоров и мьютексов есть одно существенное отличие - у мьютекса есть владелец, а у семафора нет. Снять блокировку с мьютекса может только тот поток, который последним его заблокировал. У семаформа менять значение счётчика может любой поток. Для осознание того, на сколько это различие существенно, рассмотрим пример с критической секцией. В одном случае взаимоисключающий доступ к ней реализовн при помощи мьютекса, в другом с помощью семафора. В случае мьютекса, никакой другой поток, кроме владельца не может снять блокировку с мьютекса, таким образом в критической секции гарантированно может исполняться только один поток. В случае с семафором возможно следующее. Поток декрементировал счётчик с __1__ в __0__ и вошёл в критическу секцию, а в это время какой-то сторонний поток решил увеличить значение счётчика, таким образом, к критической секции получили доступ другие потоки, помимо того, который сейчас в ней исполняется.  

Таким образом, для защиты критических секций используют именно мьютексы, поскольку это надёжно, в отличии от использования для этой цели семафоров.

#### Реализация в POSIX

__Мьютексы__

Мьютексы можно создавать для синхронизации потоков в одном процессе или же для синхронизации потоков в разных процессах. Во втором случае мьютекс требуется создать в разделяемой между соответсвующими процессами области памяти.

* __pthread_mutex_init()__ - инциализирует структуру мьютекса _pthread_mutex_t_. [Документация.](https://docs.oracle.com/cd/E26505_01/html/816-5168/pthread-mutex-init-3c.html#scrolltoc)

__сигнатура:__

``` C
#include <pthread.h> 

int pthread_mutex_init(pthread_mutex_t *restrict mutex,
     const pthread_mutexattr_t *restrict attr);
```

Ф-ция инициализирует структуру _pthread_mutex_t_ по указателю _mutex_. Параметр _attr_ указывает на структуру параметров мьютекса типа _pthread_mutexattr_t_, которыми мьютекс будет инициализирован. Если значение _attr_ равно NULL, то мьютекс инициализируется атрибутами по-умолчанию. В случае успешного завершения, мьютекс инициализируется и является незаблокированным. В случае выполнения других операций над неинициализированным мьютексом, результат будет неопределён.

Перед освобождением памяти из под мьютекса его необходимо уничтожить, вызвав _pthread_mutex_destroy_ (будет рассмотрено далее). Операции над мьютексом могут приводить к выделению дополнительной памяти или к размещению дополнительных объектов ядра ОС, поэтому освобождение памяти из под мьютекса без предварительного вызова _pthread_mutex_destroy(3C)_ может приводть к утечке памяти или исчерпанию системных ресурсов.

__возвращаемые значения__

В случае успеха, ф-ция возвращает 0, в противном случа - код ошибки.

__коды ошибок__

```
EAGAIN - системе не хватает ресурсов (отличных от памяти) чтобы инициализировать новый мьютекс.

EBUSY - попытка реинициализировать мьютекс типа robust.

EINVAL - Обнаружена попытка повторной инициализации мьютекса, ранее инициализированного с другим набором атрибутов. Также может вернуться, если значение указанное структурой pthread_mutex_t или pthread_mutexattr_t некорректно.

ENOMEM - Недостаточно памяти для инициализации мьютекса.

EPERM - у потока нет полномочий для совершения операции.
```

---

* __pthread_mutex_destroy()__ - уничтожает проинициализированную структуру мьютекса. [Документация.](https://docs.oracle.com/cd/E26505_01/html/816-5168/pthread-mutex-init-3c.html#scrolltoc)

__сигнатура:__
``` C
#include <pthread.h>

int pthread_mutex_destroy(pthread_mutex_t *mutex);
```

Ф-ция уничтожает структуру мьютекса по указателю _mutex_. После успешного завершения данной ф-ции, структуру, на которую указывает параметр _mutex_ снова можно будет инициализировать посредством вызова _pthread_mutex_init(3C)_. Любое другое использование неинициализированного мьютекса будет иметь неопределённое поведение.  

Безопасно уничтожать можно только проинициализированный и незаблокированный мьютекс. В противном случае _pthread_mutex_destroy(3C)_ либо завершится с ошибкой, либо будет иметь неопределённое поведение.  

__возвращаемые значения:__

В случае успеха, ф-ция возвращает 0, в противном случае - код ошибки.

__ошибки:__

```
EBUSY - попытка уничтожить заблокированный мьютекс или мьютекс, используемый другими потоками.

EINVAL - некорректное значение параметра mutex.
```

---

__Атрибуты мьютекса__

Теперь рассмотим атрибуты мьютекса. Их значения указываются в структуре _pthread_mutex_attr_t_. Изменение полей данной структуры не повлияет на атрибуты мьютексов, которые были ей инициализированы. Таким образом, один объект _pthread_mutex_attr_t_ можно использовать для инициализации нескольких мьютексов.  

Список атрибутов мьютекса следующий:
* ___pshared___
* [type](https://docs.oracle.com/cd/E26505_01/html/816-5168/pthread-mutexattr-settype-3c.html#scrolltoc)
* ___protocol___
* ___prioceiling___
* ___robust_np___

Атрибут __pshared__ отвечает за область действия мьютекса. Данный атрибут имеет два допустимых значения:  

* _PTHREAD_PROCESS_SHARED_ - мьютекс, который можно использовать для межпроцессного взаимодействия. Для того, чтобы использовать такой мьютекс, его необходимо разместить в разделяемой памяти, к которой соответствующие процессы будут иметь доступ.  
<br/>
* _PTHREAD_PROCESS_PRIVATE_ - мьютекс, который используется только для взаимодействия нитей в рамках одного процесса.  

Атрибут __type__ определяет способ проверки ошибок при работе с мьютексом. Допустимые значения:  

* _PTHREAD_MUTEX_NORMAL_ - какие либо проверки на ошибки отсутствуют. Однако, многократный захват такого мьютекса одной и той же нитью приведёт к мёртвой блокировке.  
<br/>

* _PTHREAD_MUTEX_ERRORCHECK_ - все операции над мьютексом сопровождаются проверкой его состояния и возвращают ошибки при недопустимых пос-тях операций. При данном значении атрибута _type_ работа с мьютексом требует гораздо больше вычислений, чем при работе с мьютексом, имеющим значение _NORMAL_.  
<br/>

* _PTHREAD_MUTEX_RECURSIVE_ - допускается многократный захват мьютекса одной и той же нитью. Такой мьютекс хранит счётчик захватов и должен быть осбождён нитью столько раз, сколько она его захватила, чтобы оставить мьютекс в незахваченном состоянии. Другие попытки освобождения приводят к ошибке.  
<br/>

* _PTHREAD_MUTEX_DEFAULT_ - в соответствии со стандартом POSIX, проверки на ошибки отсутствуют, при этом повторный захват такого мьютекса нитью может приводить к непредсказуемым последствиям вплоть до аварийного завершения процесса. Реализация стандарта имеет право отображать данное значение _type_ на любое другое. Так, в Solaris 10 значение _PTHREAD_MUTEX_DEFAULT_ соответствует _PTHREAD_MUTEX_NORMAL_. Является значением __по умолчанию__, как не странно.   

Атрибут __protocol__ описывает схему предотвращения инверсии приоритета. Инверсия приоритета - процесс, при котором низкоприоритетная нить удерживает мьютекс, на котором ожидает высокоприоритетная нить. Под приоритетом нити имеется в виду её приоритет на исполнение. Допустимые значения:    

* _PTHREAD_PRIO_NONE_ - не предусматривается никакой борьбы с инверсией приоритета. Значение __по умолчанию__.   
<br/>

* _PTHREAD_PRIO_INHERIT_ - приоритет нити, захватившей мьютекс повышается до самого высокого приоритета из нитей, ожидающих освобождения мьютекса.  
<br/>

* _PTHREAD_PRIO_PROTECT_ - приоритет нити, удерживающей мьютекс равен приоритету, указанному в св-ве _priocelling_ этого мьютекса.  

_Примечание:_ Если нить удерживает несколько мьютексов, то её приоритет, будет равен наибольшему из приоритетов на каждом из этих мьютексов. (Для нитей со значением _protocol_, равному _PTHREAD_PRIO_INHERIT_ и _PTHREAD_PRIO_PROTECT_)  

Атрибут __prioceiling__ задаёт приоритет для мьютексов со значением __protocol__ равным _PTHREAD_PRIO_PROTECT_. Для мьютексов с другим значнением поля __protocol__ данный атрибут игнорируется.  

Атрибут __robust_np__ является атрибутом, который не регламентируется стандартом POSIX (суффикс __np__ означает _not POSIX_). Он реализован в Solaris и появился в версии 2.6 ядра Linux. Данный атрибут определяет поведение, в случае, когда нить, в которой удерживается мьютекс завершается без снятия блокировки с него.   

__robust_np__ может принимать два значения - _PTHREAD_MUTEX_ROBUST_NP_ и PTHREAD_MUTEX_STALLED_NP (__по умолчанию__).  

PTHREAD_MUTEX_STALLED_NP - мутекс, удерживавшийся нитью остаётся в занятом состоянии и попытки новых нитей его захватить блокируются.  

_PTHREAD_MUTEX_ROBUST_NP_ - в данном случае мьютекс реализует более сложное поведение. Нить, первая пытающаяся захватить мьютекс получает ошибку _EOWNERDEAD_ при вызове _pthread_mutex_lock()_, однако, мьютекс она захватывает. После этого нить должна привести разделяемые ресурсы, которые защищал данный мьютекс в согласованное состояние, т.к. они могли остаться несогласованными после завершения нити-хозяина. Если ей это удаётся, то она должна вызвать _pthread_mutex_consistent_np()_, после этого нормальная работа с мьютексом может быть продолжена. Если же в согласованное состояние ресурсы привести не удалось, тогда нить должна просто освободить мьютекс. После этого дальнейшие попытки захватить такой мьютекс будут завершаться с кодом ошибки _ENOTRECOVERABLE_.  

__Задание атрибутов мьютекса__

Для задания конкретных значений атрибутов мьютекса, отличных от значений по умолчанию, требуется инициализировать этими значениями структуру _pthread_mutexattr_t_, затем инициализировать сам мьютекс, используя в качестве параметра _attr_ данную структуру в ф-ции _pthread_mutex_init(3C)_.  

Для каждого атрибута существуют ф-ция _set_, устанавливающая конкретное значение соответствующего атрибута в структуру _pthread_mutexattr_t_. Рассмотрим одну из таких ф-ций:

* __pthread_mutexattr_settype()__ - устанавливает значение атрибута _type_ в структуру _pthread_mutexattr_t_. [Документация.](https://docs.oracle.com/cd/E26505_01/html/816-5168/pthread-mutexattr-settype-3c.html#scrolltoc)

__сигнатура:__
``` C
#include <pthread.h>

int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int type);
```

Ф-ция устанавливает атрибут _type_ у структуры _attr_ в значение, специфицированное параметром _type_. Возможные значения _type_ определены в pthread.h, это следующие константы - PTHREAD_MUTEX_NORMAL, PTHREAD_MUTEX_ERRORCHECK, PTHREAD_MUTEX_RECURSIVE, PTHREAD_MUTEX_DEFAULT.  

__возвращаемые значения:__

В случае успеха ф-ция возвращает 0, в противном случае - код ошибки.

__ошибки:__

```
EINVAL - значение type некорректно. Эта же ошибка, если значение attr некорректно.
```

---

__Действия с мьютексами__

Как упоминалось ранее для мьютексов определены операции _блокировки_ и _снятия блокировки_. Рассмотрим соответствующие ф-ции в POSIX THREAD API:


__Семафоры__

Теперь рассмотрим средства API для использования POSIX-семафоров.

__инициализация семафора__

* __sem_init()__ - ф-ция инициализирует семафор с начальным начением счётчика, указанным параметром. [Документация.](https://docs.oracle.com/cd/E26505_01/html/816-5171/sem-init-3rt.html#REFMAN3Dsem-init-3rt)

__сигнатура:__

``` C
#include <semaphore.h>

int sem_init(sem_t *sem, int pshared, unsigned int value);
```

Ф-ция инициализирует структуру _sem_t_ по указателю _sem_ с начальным значением счётчика равным _value_. Параметр _pshared_ представляет из себя опцию для межпроцессного взаимодействия. Если он имеет ненулевое значение, то проинициализированый семафор может быть использован другим процессом, который имеет к нему доступ. Если _pshared_ имеет значение 0, то семафор используется потоками в рамках одного процесса, результат использования данного семафора потоками за пределом процесса, в котором он был объявлен - неопределён.  

Успешно проинициализированный семафор может быть использован до тех пор, пока не будет уничтожен посредством вызова _sem_destroy()_.

Для синхронизации может быть использован только тот семафор, область памяти которого была пронициализированна непосредственно _sem_init()_, результат операций над копиями семафора неопределён.  

Попытка проинициализировать уже проинициализированный семафор будет иметь неопределённое поведение.  

__возвращаемые значения:__

В случае успеха, ф-ция инициализирует семафор. В противном случае возвращается -1 и в _errno_ установлен код ошибки.  

__ошибки:__
``` C
EINVAL - значение value превышает максимальное допустимое (SEM_VALUE_MAX)
ENOSPC - исчерпаны ресурсы для инициализации нового семафора, или достигнуто предельное кол-во таких ресурсов (SEM_NSEMS_MAX)
ENOSYS - ф-ция sem_init() не поддерживаема системой
EPERM - процесс не обладает необходимыми привелегиями для инициализации семафора.
```

---

__уничтожение семафора__

* __sem_destroy()__ - уничтожает семафор по указанному указателю.

__сигнатура:__

``` C
#include <semaphore.h>

int sem_destroy(sem_t *sem);
```

Ф-ция уничтожает семафор по указателю _sem_. Данную ф-цию можно применять только к семафору, который был инициализирован при помощи _sem_init()_. Результат работы ф-ции применённой к семафору, который уже был уничтожет с её помощью - неопределён, до тех пор, пока семафор не будет заново проинициализирован _sem_init()_.  

__возвращаемые значения:__

В случае успеха ф-ция возвращает 0. В противном случае, возвращается -1 и значение _errno_ установлено в код ошибки.  

__ошибки:__

```
EINVAL - аргумент sem указывает на невалидный семафор

EBUSY - на данном семафоре заблокированы процессы или потоки, т.е. они заблокированы на вызове _sem_wait()_ к данному семафору.  
```

---

__операции над семафорами__

* __sem_post()__ - инкремент счётчика семафора.

__сигнатура:__

``` C
#include <semaphore.h>

int  sem_post ( sem_t * sem );
```
_sem_ - указатель на структуру семафора, к которому применяется операция.  

Если значение счётчика семафора к момент вызова данной ф-ции равно 0, то одному из потоков, которые заблокированы на _sem_wait()_ будет разрешено вернуться из её вызова. Если значение счётчика семафора к моменту вызова ф-ции положительно, то ни один поток на семафоре не заблокирован и значение счётчика просто увеличивается.  

__возвращаемые значения:__
В случе успеха, ф-ция возвращает 0. В противном случае возвращается -1 и значение _errno_ установлено в код ошибки.  

__ошибки:__

```
EINVAL - sem указывает на невалидный семафор.

ENOSYS - ф-ция не поддерживаема системой.

EOVERFLOW - значение счётчика семафора превысило максимальное (SEM_VALUE_MAX).
```

* __sem_wait()__ - декремент счётчика семафора.

__сигнатура:__

``` C
#include <semaphore.h>

int sem_wait(sem_t *sem);
```

Если значение счётчика семафора к моменту вызова ф-ции равно 0, то поток блокируется на вызове _sem_wait()_. Если значение счётчика положительно, то происходит его декремент и операция завершается.  

__возвращаемые значения:__

В случае успеха ф-ция возвращает 0. В противном случае, возвращается -1 и значение _errno_ установлено в код ошибки.  

__ошибки:__

```
EINVAL - sem указывает на невалидный семафор.

ENOSYS - ф-ция не поддерживаема системой.

EDEADLK - мёртвая блокировка. Два процесса залокированы на одном и том же семафоре и каждый ждёт, когда другой проинкрементирует счётчик.  

EINTR - ф-ция была прервана посредством сигнала.
```

### Библиотечные ф-ции сетевых сервисов

В этом разделе содержится документация к сетевому API BSD (Bercley Software Distribution), реализация которого поддерживается на различных дистрибутивах Linux, а также в Solaris. Собственно данный интерфейс специально разрабатывался для UNIX-подобных операционных систем. 

Сокеты Беркли стали стандартом для реализации сетевого взаимодействия в програмном обеспечении, и их реализация поддерживается на большинстве ОС в том или ином виде: на Window они реализованы как Windows sockets API, которая основана на сокетах Беркли (ф-ции доступны из заголовочного файла winsock.h), в Solaris и различных дистрибутивах Linux они имеют стандартную UNIX-реализацию (ф-ции определены в заголовочных файлах sys/socket.h, netinet/in.h, sys/un.h, arpa/inet.h, netdb.h).

#### Концепция Сокетов

#### Документация

* __socket()__ - создание непривязанного сокета.

__сигнатура:__
``` C
#include <sys/socket.h> 

int socket(int domain, int type, int protocol);
```

Ф-ция создаёт непривязанный сокет в указанном домене (_domain_) комуникации.

В sys/socket.h определены следующие значения доменов:

__AF_UNIX__ - сокет используется для межпроцессного взаимодействия на одном устройстве.

__AF_INET__ - сетевое взаимодействия по _IPv4_.

__AF_INET6__ - сетевое взаимодействия по _IPv6_.

Аргумент _type_ задаёт семантику передачи данных через сокет. Возможные значения _type_ являются платворменно-зависимы, но основные значения следующие:

__SOCK_STREAM__ - обеспечивается надёжное соединение для двусторонней передачи упорядоченного потока байт.

__SOCK_DGRAM__ - передача данных идёт без предварительного установления соединения. Данные передаются дейтаграммами с фиксированной максимальной длинной.

__SOCK_SEQPACKET__ - аналогичен __SOCK_STREAM__, за исключением того, что используется для передачи отдельных ограниченных сообщений, а не потока байт. Граница записи видна получателю сообщения через флаг _MSG_EOR_, указываемый в ф-ции _send()_. 

Аргумент _protocol_ специфицирует конкретный протокол транспортного уровня. Если _protocol_ равен 0, то будет использован протокол по-умолчанию для соответствующего типа сокета.  

__возвращаемые значения__

В случае успеха, ф-ция возвращает значение дескриптора сокета. В противном случае -1 и в errno устанавливается код ошибки.  

---

* __bind()__ - привязка сокета к определённому адресу сетевого нтерфейса на устройстве.

__сигнатура:__

``` C
#include <sys/socket.h>

int bind(int socket, const struct sockaddr *address,
     socklen_t address_len)
```

Аргументы ф-ции следующие:

___socket___ - дескриптор сокета.

___address___ - указатель на структуру _sockaddr_, в которой содержится адресс.

___address_len___ - размер структуры _sockaddr_, в зависимости от типа сокета, очевидно, может быть разной.

__возвращаемые значения__

В случае успеха, ф-ция возвращает 0. В противном случае -1 и в errno устанавливается код ошибки.  

---

* __listen()__ - перевод сокета в режим ожидания входящих соединений.  

__сигнатура:__

``` C
#include <sys/socket.h>

int listen(int socket , int backlog );
```

Ф-ция переводит сокет, указанный файловым дескриптором _socket_ в режим ожидания входящих соединений, и ограничивает число соединений в очереди на принятие сокета до значения, указанного аргументом _backlog_.  

Если _backlog_ меньше нуля, то размер очереди непринятых соединений устанавливается в 0.  

Значение _backlog_ может привысить максимальный размер очереди, поддерживаемый системой. В таком случае, он будет установлен в это предельное значение.  

__возвращаемые значения__

В случае успеха, ф-ция возвращает 0. В противном случае -1 и значение _errno_ установлено в код ошибки.  

---

* __accept()__ - создание сокета на входящее соединение.  

__сигнатура:__
``` C
#include <sys/socket.h>

int accept(int socket, struct sockaddr *restrict address,
     socklen_t *restrict address_len);
```

Ф-ция изымает первый элемент из очереди входящих соединений и инициализирует по нему новый сокет того же _типа_ и _протокола_, что и указанный сокет - _socket_, затем аллоцирует новый файловый дескритор для этого сокета и возвращает его целочисленный идентификатор.  

Ф-ция имеет следующие аргументы:

_socket_ - дескриптор сокета, который был создан и привязан на данном устройстве и для которого ф-ция _listen()_ успешно завершилась.  

_address_ - либо _NULL_ (если адрес клиентского сокета нам неинтересен), либо указатель на структуру _sockaddr_, куда будет помещён адресс созданного сокета.  

_address_len_ - указатель на стуктуру _socklen_t_, куда будет помещена длина структуры _sockaddr_

Если очередь входящих подключений пуста, то вызов _accept()_ блокируется, до тех пор, пока не появится новое входящее соединение.  

Новый клиетский сокет, не может работать в режиме принятия соединений. Он может быть использоват только для обмена данными с клиентом.  

__возвращаемые значения__

В случае успеха, ф-ция возвращает неотрицательное значение дескриптора созданного сокета. В противном случае, -1 и значение _errno_ установлено в код ошибки.  

---

* __connect()__ - запрашивание создания соедиения для указанного сокета.  

__сигнатура:__

``` C
#include <sys/socket.h>

int connect(int socket, const struct sockaddr *address,
    socklen_t address_len);
```

Ф-ция имеет следующие аргументы:

_socket_ - файловый дескриптор сокета.    

_address_ - указатель на структуру _sockaddr_, которая содержит адресс удалённого точки подключения.  

_address_len_ - специфицирует размер структуры _sockaddr_, на которую указывает _address_.  

Если подключение не может быть осуществлено немедленно, то вызов _connect()_ блокируется до тех пор, пока оно не будет доступно, либо по истичении временного таймаута. Во втором случае, ф-ция завершится с ошибкой.  

В случае, если ф-ция _connect()_ по каким-то причинам завершается с ошибкой, то дальнейшее поведение сокета при его использовании неопределено.  

__возвращаемые значения__

В случае успеха, ф-ция возвращает 0, в противном случае -1 и значение _errno_ устанавливается в код ошибки.  

---

* __send()__ - передача сообщения через сокет.

__сигнатура__

``` C
#include <sys/socket.h>

ssize_t send(int socket, const void *buffer, size_t length, int flags);
```

Параметры ф-ции:

_socket_ - файловый дескриптор сокета.

_buffer_ - указатель на буффер, содержащий сообщение для отправки.  

_length_ - длина сообщения в байтах.  

_flags_ - тип передачи сообщения. Его значение формируется поразрядной дизъюнкцией 0 или более флагов: _MSG_EOR_ - завершение записи (для сокетов _SOCK_SEQPACKET_), _MSG_OOB_ - передача внеполосных данных __?__

Ф-ция отправляет сообщение только тогда, когда сокет подключен. Длина отправляемого сообщения определяется аргументом _length_. Если в буфере сокета нет места для хранения передаваемого значения и он не находится в режиме _O_NONBLOCK_, то ф-ция блокируется до тех пор, пока место не появится.  

Если собщение слишком большое, чтобы передаться через сокет в рамках соответствующего протокола, то ф-ция завершается с ошибкой.  

Если для отправки сообщения отсутствует место в буфере сокета и сокет не находится в режиме _O_NONBLOCK_, вызов ф-ции блокируется до тех пор, пока место в буфере не станет доступным.  Если же в буфере отсутствует место и сокет находится в режиме _O_NONBLOCK_, то ф-ция завершится с ошибкой.  

__возвращаемые значения__

В случае успеха ф-ция возвращает кол-во отправленных байтов, причём её успешное завершение не гарантирует доставку сообщения. В случае возникновения ошибки, возвращается -1 и значение _errno_ устанавливается в код ошибки.  

---

* __recv()__ - получение сообщения через сокет.

__сигнатура:__

```C
#include <sys/socket.h>

ssize_t recv(int socket, void *buffer, size_t length, int flags);
```

Параметры ф-ции:

_socket_ - файловый дескриптор сокета

_buffer_ - указатель на буффер, куда будут помещены считанные данные.

_length_ - длина буфера в байтах.

_flags_ - тип приёма сообщения. Значение формируется путём поразрядной дизъюнкции 0 и более значений: _MSG_PEEK_ - режим просмотра сообщения. Полученные даные помечаются как 'непрочитанные' и последующие ф-ции чтения из сокета всё равно вернут эти же данные. _MSG_OOB - запрос на внеполосные данные __?__. _MSG_WAITALL_ - ф-ция чтения блокируется до тех пор пока не будет прочитано полное запрошенное сообщение, в случае если пойман сигнал, прервано соединение, возникла ошибка, или в _flag_ было указано значение _MSG_PEEK_, то ф-ция может завершиться записав неполный объём данных.  

Для сокетов типа _SOCK_DGRAM_ или _SOCK_SEQPACKET_ всё сообщение должно быть прочитано за одну операцию. Если буффер слишком мал для того, чтобы вместить полное сообщение, то лишние байты сообщения отбрасываются.  Для сокетов типа _SOCK_STREAM_, данные записываются, как только становятся доступными и в этом случае, никакие байты не отбрасываются.  

Если доступных сообщений нет, и режим _O_NONBLOCK_ не установлен, то ф-ция блокируется до тех пор, пока сообщение не прибудет. Если доступных сообщений нет, и режим _O_NONBLOCK_ установлен, то ф-ция завершается с ошибкой.  

__возвращаемые значение__

В случае успеха, ф-ция возвращает длину прочитанного сообщения в байтах. Если доступных сообщений нет и удалённый хост отключился от соединения, то возвращается 0. В противном случае, возвращается -1 и значение _errno_ устанавливается в код ошибки.


