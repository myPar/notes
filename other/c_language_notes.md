## Средства языка Си

#### Основные понятия

##### Объявление и определение
* __Объявленение__ - _объявление_ переменной или ф-ции предназначено для того, чтобы сообщить компилятору, что переменная или ф-ция существует где-то в программе, но указания компилятору для алоцирования под них памяти нет.
_Объявление_ или _Декларация_ подразумевает определение _сигнатуры_. В случае ф-ции это _идентификатор_(имя) ф-ции, _тип возвращаемого значения_, _параметры ф-ции_ их типы и порядок. В случае переменной это указание его типа и имени.  
<br/>

* __Определение__ - _определение_ (или _реализация_) переменной или ф-ции подразумевает, что к тому, что уже делает _объявление_, оно дополнительно указывает компилятору на аллоцирование памяти для этой переменной или ф-ции и на место. В случае перемено, также указывается где эта память будет аллоцирована.  

Декларация одной и той же переменной или ф-ции в одном файле программы может быть осуществлено __множественное__ кол-во раз, однако определено всего __единожды__. Также важно отметить, что множественная декларация локальных переменных, т.е. внутри ф-ции, запрещено, поскольку это считается уже не _объявлением_, а _определением_, поскольку место, где будет храниться значение переменной указывается явно, и это - стек.  

_Примечание:_ под "указаниям компилятору" алоцировать память подразумевается, что она не выделяется физически (поскольку это происходит на стадии исполнения процесса), а лишь указываются соответствующие команды в ассемблерном коде.  

__Пример:__
``` C
#include <stdio.h>
int var;    //
int var;    // декларация (объявление)

int foo(int a); // декларация (объявление)

int main() {
    var = 10;       // определение
    printf("%d\n", var);

    return foo(0);
}
int foo(int a) {    // определение
    return a;
}

```

#### Ключевые слова

* __extern__ - ключевое слово, использующееся при объявлении переменной или ф-ции, указывающая компилятору на то, что её определение находится где-то ещё. Также, при этом область видимости данной переменной или ф-ции расширяется до всей программы.  
<br/>

    __использование:__
    _extern_ используется для обеспечения ссылочности на определения глобальных переменных или ф-ций из другого файла программы. Как это используется - в заголовочном файле, где мы планируем объявить наши глобальные переменные и ф-ции мы делаем это, используя ключевое слово _extern_. В одном исходном _c_-файле мы подключаем данный заголовочный файд и реализуем их. В другом исходном _с_-файле, мы можем эту реализацию использовать, подключив предварительно вышеупомянутый заголовок.  

#### Массивы и указатели

Массив представляет из себя упорядоченный набор данных, в строго типизированных языках в т.ч. и в С, содержащий значения одного типа.  

Поскольку массив является упорядоченным набором данных можно осуществить однозначную индексацию каждого его элемента.  

В виртуальной памяти процесса, данные массива расположены линейно и в том же порядке, что и в вашем исходном коде.  (картинка)

__объявление и инициализация__

``` C
int arr[5] = {1,2,3,4,5};   // с указанием размера массива
---
int arr[] = {1, 2, 3, 4, 5};    // компилятор сам определит размер массива и выделяет соответсвующее кол-во памяти
---
int arr[10] = {};           // массив инициализируется нулями, причём массив может быть произвольной размерности
---
#define SIZE 5              // инициализация с указанием размера compile-time константой

int arr[SIZE] = {1, 3, 4, 5, 0};
```
Если указать размер массива не compile-time константой, то произойдёт ошибка компиляции. Чтобы указать размер массива значением, вычесленным на стадии работы программы используют аллоцирование динамической памяти:

``` C
#include <stdlib.h>

int array_size = 100;

int *arr = (int*) malloc(sizeof(int) * array_size); // возвращается указатель на выделенную область памяти, имеющий соответствующий тип
```

__адресация__

Обращение к массиву, как к типизированной переменной всегда происходит, как к ___указателю на первый элемент___ этого массива.  Т.е. если мы имеет массив _int arr[3][4][5]_, то он фактически, как переменная, будет иметь тип _int (*arr)[4][5]_.  

Согласно арифметике указателей мы можем получить значение элемента массива c индексом ___i___ следующим образом:  

``` C
int arr[10] = {1, 12, 3, 4, 5, 12, 5, 6, 7, 10};

int item = *(arr + i);
```

Разберём что здесь происходит: к указателю на первый элемент массива _arr_ прибавляется смещение i (это смещение в кол-ве элементов, а не в кол-ве байт!), полученный указатель разыменовывается и, поскольку элементы массива в виртуальной памяти расположены линейно, получаем значение элемента массива с индексом ___i___.  

Операция обращения к элементу массива через квадратные скобки, эквивалента вышеописанной:

``` C
int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

int item = arr[i];
```

Здесь также происходит смещение от указателя на первый элемент на ___i___ элементов, затем происходит разыменовывание полученного указателя.  

#### Библиотечные ф-ции

* __strtol()__ - ф-ция конвертирования строки в численное представление типа ___long int___.

__сигнатура:__

``` C
#include <stdlib.h>

long strtol(const char *restrict str, char **restrict endptr, int base);
```

Ф-ция последовательно обрабатывает строку _str_ минуя символы пробела, и составляет результрующую строку, которую в дальнейшем будет конвертировать в целое число. Результирующая строка включает в себя символы, соответствующие цифрам в системе счисления, определённой аргументом _base_. Как только, ф-ция встречает символ, отличный от допустимова в соответствующей системе счисления, результирующая строка считается составленной и дальше происходит её преобразование к целому числу. Первый встреченный недопустимый символ в строку не включется. Символ '-' также является допустимым, если указан в начале результирующей строки.   

Указатель на результирующую строку помещается в переменную _end_ptr_, если она не является _NULL_.  

В случае успеха ф-ция возвращает сконвертированное целочисленное значение. Если конвертирование не может быть произведено, то возвращается 0 и _errno_ может быть установлено в значение _EINVAL_.  

Если конвертируемая строка является корректной, но результирующее целое число находится за пределом допустимых значений _long int_, то возвращается константа _LONG_MAX_ или _LONG_MIN_, в зависимости от знака этого числа, и в _errno_ устанавливается значение _ERANGE_.  

__ошибки:__
```
ERANGE - возвращаемое значение непредставимо в рамках допустимого типа.  
EINVAL - значение base недопустимо.  
```

### Представление чисел в памяти

#### Целые числа

Есть несколько способов представления целых чисел в памяти компьютера, каждый из них имеет свои плюсы и недостатки. Разные способы представления могут использоваться для разных целей в аппаратных реализациях. Про представления целых чисел хорошо достаточно подробно написано [здесь](https://neerc.ifmo.ru/wiki/index.php?title=%D0%9F%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D1%86%D0%B5%D0%BB%D1%8B%D1%85_%D1%87%D0%B8%D1%81%D0%B5%D0%BB:_%D0%BF%D1%80%D1%8F%D0%BC%D0%BE%D0%B9_%D0%BA%D0%BE%D0%B4,_%D0%BA%D0%BE%D0%B4_%D1%81%D0%BE_%D1%81%D0%B4%D0%B2%D0%B8%D0%B3%D0%BE%D0%BC,_%D0%B4%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4).  

__Прямой код__ - старший бит является знаковым, 0 - соответствует положительному числу, 1 - отрицательному. Каждое число, кроме нуля представляется как запись его модуля и знака в старшем бите. В этом способе представления чисел два нуля один положительный, другой - отрицательный, отличающиеся между собой значением в знаковом бите. Таким образом, этим способом можно представить целые числа в диапазоне $[-2^{n-1} + 1, 2^{n-1} - 1]$, где _n_ - число бит, отведённое под соответствующий тип числа.  __КАРТИНКА?__

* __Преимущества__
    * простота получения прямого кода числа
    * кол-во положительных чисел равно кол-ву отрицательных
* __Недостатки__
    * Выполнение арифметических операций с отрицательными числами трбует усложнения архитектуры процессора. (например, при таком представлении чисел, для вычитания невозможно использовать сумматор, требуется реализация отдельной схемы для этого)
    * Существование двух нулей, из-за чего усложняется арифметическое сравнение.

__Код со сдвигом__ - при данном способе к числу прибавляется значение $2^n$ и полученное число уже кодируется в двоичной системе счисления. Визуально, кодируемое мн-во целых чисел сдвигается на $2^n$ вправо. Таким образом, можно представить целые числа в диапазоне $[-2^{n-1}, 2^{n-1}-1]$. Данное представление используется для хранения _порядка_ в вещественных числах, но для хранения целых чисел как типа, на практике применяется редко, из-за указанных ниже недостатков. 
__КАРТИНКА?__

* __Преимущества__
    * Не требуется усложнения архитектуры процессора.
    * Нет проблемы двух нулей.
* __Недостатки__
    * Несимметричность ряда положительных и отрицательных чисел.
    * При арифметических операциях нужно учитывать смещение. Например, при сложении двух чисел мы также имеем два смещения, одно из которых требуется вычесть из результата. Т.е. проделывается на одну операцию больше.

#### Числа с плавающей запятой

Представление в памяти чисел с плавающей запятой имеет три компоненты __знак__ (_digit_), __мантису__ (_mantis_) и __порядок__ (_exponent_). Согласно стандарту _IEEE 754_ эти три компоненты представляются в виде последовательного набора битов, часть из которых кодирует мантису, часть - порядок и один - знак (0 - если число положительное и 1, если отрицательное). Порядок записывается, как целое число в _коде со сдвигом_ (см.выше), а мантиса в _нормализованном виде_.

Такое представление соответствует числу, вычисляемому по следующей формуле:

$(-1)^S \times M \times B^E$ где $B$ - основание, $E$ - порядок, $M$ - мантисса.  

__Нормальная и нормализованная формы__

_Нормальной формой_ числа с плавающей запятой называется наз-ся такой вид записи числа, в котором мантисса в дисятичной системе нах-ся на полуинтервале $[0,1)$. Такая запись имеет недостаток - одно и то же число может быть записано несколькими способами: $0.0001 = 0.0001 \times 10^0 = 0.001 \times 10^{-1} = 0.01 \times 10^{-2}$. Существует другая запись числа, называемая _нормализированной_, в ней мантисса принимает значения от 1 (включительно) до 2 (невключительно), запись двоичная. Т.е. слева от запятой мантисса всегда имеет один разряд, причём равный 1, а справа идёт запись дробной части. При такой записи вещественные числа представляются однозначно, это можно легко доказать: __ДОКАЗАТЕЛЬСТВО__

Поскольку слева от запятой в нормализированном виде мантиса всегда имеет один бит, значение которого равно единице, то его можно опустить и не хранить в памяти. Таким образом будет сэкономен один бит. Стандарт IEEE 754, как раз предусматривает такой способ хранения мантиссы.  

__Проблемы арифметики чисел с плавающей запятой__

Числа с плавающей запятой представляют из себя конечное мн-во, на которое отображается бесконечное мн-во вещественных чисел. Следовательно исходное число может быть представлено в экспоненциальной записи с ошибкой (округляется до ближайшего представимого). Округление результата любой арифметической опрации осуществляется до бижайшего к результату числа, представимого в соответствующем типе вещественного числа. Из этого следует неассоциативность любых арифметических операций над вещественными числами. Результаты операций в зависимости от порядка будут отличаться, как раз из-за такого округления.  

