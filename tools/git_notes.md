### Структура git

* __BLOB__ - содержимое файла, без какой либо метаинформации, только байты содержимого. Каждый BLOB идентифицируется __хэшем__ (SHA-1), который конструируется только на основе байт данных файла.

* __TREE__ - информация дирректории. Содержит хэши объектов внутри дирректории (BLOBs + TREEs). Также имеет свой собственный хэш. Каждая запись имеет спецификатор доступа, хэш и имя объекта внутри дирректории, которую отслеживает дерево.  

* __COMMIT__ - "снимок" какого-то TREE. Содержит хэш дерева, метаинформацию (автор коммита, дата коммита и пр.), родительские коммиты (их хэши). Также имеет свой хэш.

Хэши каждого вышеперечисленного объекта зависят от содержимого, т.е. если мы изменим данные какого-то BLOB'а, то хэши изменятся и у него, и у всех родительских элементов.Эти изменения будут отображены в новом коммите, который будет ссылаться на родительский.  

* __BRANCH__ - просто ссылка на __COMMIT__, при добавлении дочернего комита (не считая merge-коммита) указатель ветки перемещается на него. Вообще говоря, любой коммит может быть либо _достижимым_ либо _недостижимым_. 
    - ___Достижимый коммит___ - это тот коммит, который связан однонаправленной цепью коммитов с коммитом какой либо ветки.
    - ___Недостижимый коммит___ - тот коммит, для которого такая цепь не существует.  

Недостижимые коммиты впоследствии удаляются сборщиком мусора.

Важно понимать что в истории коммитов каждый файл будет иметь свою последовательность снимков, т.е. каждый коммит содержит данные файла на этом шаге (не изменения), если же файл не был изменён, то хранится ссылка на его снимок из родительского коммита, в целях экономии памяти.  

Индексация файла - произведение снимка состояния файла для его последующего добаввления в коммит.  

Файлы, находящиеся под версионым контролем могут находится в тёх состояниях:  

* __modified__ - в файле были проведены изменения, но они не были проиндексированны.  
* __staged__ - изменения в файле были проиндексированны, т.е. они попадут в следующий коммит.  
* __commited__ - текущее состояние файла сохранено в git, в рамках коммита.  

---

### Команды

* __git log__

``` bash
### отображение истории комитов в репозитории в обратном хронологическом порядке.
$ git log

### опция -p или --patch показывает разницу, внесённую в каждый коммит, дополнительно 
можно указать кол-во записей (2)
$ git log -p -2

### опция --stat задаёд вывод сокращённой статистики
$ git log --stat

### добавление опции --all осуществит вывод полной истории коммитов для репозитория
$ git log --all

### опция изменения формата вывода --pretty для неё существует несколько встроенных вариантов:
oneline - вывод комитов в одну строку (полезно при просмотре большого кол-ва коммитов)
short, full, fuller - по возрастанию выводимого кол-ва информации

$ git log --pretty=oneline
$ git log --pretty=short
$ git log --pretty=full
$ git log --pretty=fuller

format - позволяет задать формат вывода. Значение данной опции задаётся строкой, в
которой допускаются следующие спецификаторы формата:
%H - Хеш коммита
%h - Сокращенный хеш коммита
%T - Хеш дерева
%t - Сокращенный хеш дерева
%P - Хеш родителей
%p - Сокращенный хеш родителей
%an - Имя автора
%ae - Электронная почта автора
%cn - Имя коммитера
%ce - Электронная почта коммитера
%cd - Дата коммитера
%ad - Дата автора
%s - Содержание

$  git log --pretty=format:"commit %h, %cn, %an : %s"

### вместе с опцией format и oneline очень удобно применить опцию --graph в команде
### log, которая позволит вывести текущую ветку в виде дерева вместе с историей слияния
$ git log --pretty=format:"commit %h, %cn, %an : %s" --graph

```

* __git commit__

``` bash
### коммит изменений
$ git commit -m "commit message"

### Изменение сообщения последнего коммита. Откроетса текстовый редактор, где можно будет отредактировать сообщение.

$ git commit --ammend

### Редактирование снимка закоммиченных файлов. Нужно добавить/удалить из индекса нужные вам измененения через git add или git rm, после чего текущий снимок можно сохранить в последний коммит, тем самым отредактирровав его.

$ touch file.txt
$ git add file.txt
$ git commit --ammend
```

* __git checkout__
``` bash
### переход на определённый коммит git checkout + хэш коммита
$ git checkout 403c079561c82709c2688a39f871b13635e3ae18

### восстановление снимков файлов на определённом коммите (с добавлением в индекс, но без коммита загруженного снимка). Восстановить состояние всех файлов:  

$ git checkout 2f5acdfb3ca895dd9183bf7051518f8d041a1e3b .

### восстановить состояние определённого файла
$ git checkout 2f5acdfb3ca895dd9183bf7051518f8d041a1e3b file2.txt

### переход на существующую ветку
$ git checkout existing_branch

### создание новой ветки от текущего коммита с переходом на неё
$ git checkout -b new_branch
```

* __git rm__
``` bash
### удаление файла из проиндексированных, а также из рабочего каталога
$ git rm file1.txt

### удаление файла из индекса с сохранением в каталоге
$ git rm --cached file1.txt

### удаление папки. Нужно добавить опцию -rf (рекурсивно)
$ git rm -rf folder

### удаление версионного контроля git из проекта (удаляем папку .git)
$ git rm -rf .git
```

* __git remote__
``` bash
### отображение удалённых репозиториев
$ git remote

### отображение URL и имён удалённых репозиториев, куда вы отправляете и с которых вы забираете изменения соответственно
$ git remote -v

### добавление удалённых репозиториев
$ git remote add os_rep https://github.com/myPar/NSU_OS.git

### удаление репозитория (именной ссылки)
$ git remote remove os_rep

``` 

* __git push__
``` bash
### пуш коммита (снимка состояния проекта) в ветку удалённого репозитория
$ git push origin feature_branch
```

* __git fetch__
```
### команда git fetch забирает все измененения из удалённого репозитория и локально их сохраняет,
### без слияния с вашими текущими наработками. После этой команды у вас появятся ссылки на все ветки
### удалённого репозитория, которые впоследствии можно будет слить с локальными.  
$ git fetch 
```

* __git pull__
```
### если локальная ветка настроена на отслеживание удалённой, то можно сохранить 
### изменения с удалённой ветки и тут же попытаться их слить с текущей локальной веткой 
$ git pull

### запор изменений (новых веток) + слияние
$ git fetch
$ git checkout remote_branch_name
$ git pull
```

* __git rebase__
``` bash
### перебазирование текущей ветки на другую. Берутся все коммиты до общего предка и 
### полученная цепочка коммитов перемещается на новую ветку.
$ git rebase branch_rebase_to

### прерывание перебазирование с удалением всей служебной информации и возвратом
### в первоначальное состояние (в т.ч. с возвратом HEAD)
$ git rebase --abort

### остановка перебазирование без возврата в первоначальное состояние
$ git rebase --quit

### пропуск текущего конфликтного коммита
$ git rebase --skip
```

* __git clone__
``` bash
### клонирование существующего удалённого репозитория в текущую дирректорию
### также создаёт ссылки на удалённые ветки
$ git clone
```

### Создание нового проекта

1. Создать __пустой__ репозиторий на GitHub
2. Проинициализировать локальный репозиторий
3. Сделать начальный коммит в master
4. Сделать push коммита в ветку master на удалённый репозиторий

``` bash
$ git init
$ touch README.txt
$ git add README.txt
$ git commit -m "initial commit"
$ git push remote_name master
```

### Клонирование существующего проекта с локальной синхронизацией

1. Клонировать удалённый репозиторий
2. Сделать переход на нужные ветки и "стянуть" изменения при помощи git pull

``` bash
$ git clone https://github.com/myPar/NSU_OS.git
$ git checkout src_branch
$ git pull
```

### Слияние коммитов

При слиянии двух коммитов непересекающиеся изменения (изменения над разными строчками кода, над разными файлами) __все__ применяются в результирующем коммите. Если изменения в обоих коммитах были применены к одной и той же строчке, то возникает конфликт: в каждом файле, где такое произошло, для каждой "конфликтной" строчки отображается две версии кода - по одной из каждого коммита. При разрешении конфликтов можно выбрать одну из этих версий кода, либо переписать этот участок самому. 

#### Слияние фичи с основной веткой

Опишем наиболее частый сценарий, когда есть отдельная ветка разработки и надо её слить с master.

``` bash
$ git checkout master
$ git merge feature_branch
```

В случае конфликтов отобразятся файлы, где они произошли:
``` bash
Auto-merging feature.txt
CONFLICT (add/add): Merge conflict in feature.txt
Automatic merge failed; fix conflicts and then commit the result.
```

Требуется исправить конфликт, выбрав нужную версию кода из двух веток. Затем продолжить слияние следующей последовательностью команд:
``` bash
$ git add .
$ git commit
```

### Перебазирование

Для сохранения линейности истории коммитов лучше использовать git rebase. git rebase берёт все коммиты до общего предка (невключительно) двух веток: перебазируемой и той, на которую перебазирование происходит. Полученная цепь коммитов копируется и "применяется" к целевой ветке. После этого указатель перебазируемой ветки перемещается на новое положение. На старую цепь коммитов, которая была до перебазирования, более никакая ветка не ссылается и она будет собрана сборщиком мусора.  

Каждый коммит переносимой ветки применяется последовательно и в случае возникновения конфликтов на каждом таком шаге придётся их исправлять, пока rebase не завершиться успешно.  

При перебазировании создаются новые коммиты, поэтому их хэши отличаются от хэшей коммитов до перебазирования.  

### Обновление состояния дочерней ветки

Предположим мы работаем в своей ветке, которая является дочерней к master. В master появилась новая фича, которую мы захотели добавить. Можно применить переазирование нашей ветки к master.
``` bash
* commit 4e19ec169df3178efec7d1ed1587799b609b3bf7 (feature_branch)
| Author: myPar <andrebobrovs@mail.ru>
| Date:   Sat Feb 25 11:32:06 2023 +0700
|
|     refactored initial commit file
|
* commit a60a861e5e8801c8fd28550d6bc1668545efc0aa
| Author: myPar <andrebobrovs@mail.ru>
| Date:   Sat Feb 25 11:27:31 2023 +0700
|
|     second commit to feature branch
|
* commit 8e73c71700f6705d1fed2434e8140801586ee40e
| Author: myPar <andrebobrovs@mail.ru>
| Date:   Sat Feb 25 11:26:48 2023 +0700
|
|     fist commit to feature branch
|
| * commit 54ba37b98ea70348c0dbeb1fb671dd47871b47e0 (HEAD -> master)
|/  Author: myPar <andrebobrovs@mail.ru>
|   Date:   Sat Feb 25 11:29:01 2023 +0700
|
|       update master commit
|
* commit c08d1c1d30f56b5b1ac851ec34e90ca01084a665
  Author: myPar <andrebobrovs@mail.ru>
  Date:   Sat Feb 25 11:25:19 2023 +0700

      "initial commit to master"

```
Перемещаемся на ветку feature_branch и делаем rebase на master:

``` bash
$ git checkout fetuare_branch
$ git rebase master
```

Получаем такую картину:
```bash
$ git log --all --graph
* commit 2cd7d05388563eecf07511ce18080edc7c187e79 (HEAD -> feature_branch)
| Author: myPar <andrebobrovs@mail.ru>
| Date:   Sat Feb 25 11:32:06 2023 +0700
|
|     refactored initial commit file
|
* commit 793586250e3e67c369372a081411f18bca1bb2c2
| Author: myPar <andrebobrovs@mail.ru>
| Date:   Sat Feb 25 11:27:31 2023 +0700
|
|     second commit to feature branch
|
* commit 3aa5988f6f625d799b72f701e7766ba29e298d34
| Author: myPar <andrebobrovs@mail.ru>
| Date:   Sat Feb 25 11:26:48 2023 +0700
|
|     fist commit to feature branch
|
* commit 54ba37b98ea70348c0dbeb1fb671dd47871b47e0 (master)
| Author: myPar <andrebobrovs@mail.ru>
| Date:   Sat Feb 25 11:29:01 2023 +0700
|
|     update master commit
|
* commit c08d1c1d30f56b5b1ac851ec34e90ca01084a665
  Author: myPar <andrebobrovs@mail.ru>
  Date:   Sat Feb 25 11:25:19 2023 +0700

      "initial commit to master"

```

История коммитов стала линейной, обновлённое состояние файлов в master теперь учтено в дочерней ветке feature_branch.  

### Интерактивное перебазирование
Некоторые коммиты являются неоптимальными в плане информативности, исправляют опечатки в других коммитов, лишние коммиты с мусорными изменениями. Поэтому, в git есть средство редактирование истории коммитов, так называемый _интерактивный rebase_.  

Это обычный rebase с оптимизацией истории коммитов перебазируемой ветки. Вектку можно перебазировать саму на себя, тогда мы просто подредактируем её историю, без какого либо перемещения (по факту, конечно, это всё равно будут новые коммиты).  

Имеем следующую историю коммитов:  
``` bash
* commit 2cd7d05388563eecf07511ce18080edc7c187e79 (HEAD -> feature_branch)
| Author: myPar <andrebobrovs@mail.ru>
| Date:   Sat Feb 25 11:32:06 2023 +0700
|
|     refactored initial commit file
|
* commit 793586250e3e67c369372a081411f18bca1bb2c2
| Author: myPar <andrebobrovs@mail.ru>
| Date:   Sat Feb 25 11:27:31 2023 +0700
|
|     second commit to feature branch
|
* commit 3aa5988f6f625d799b72f701e7766ba29e298d34
| Author: myPar <andrebobrovs@mail.ru>
| Date:   Sat Feb 25 11:26:48 2023 +0700
|
|     fist commit to feature branch
|
* commit 54ba37b98ea70348c0dbeb1fb671dd47871b47e0 (master)
| Author: myPar <andrebobrovs@mail.ru>
| Date:   Sat Feb 25 11:29:01 2023 +0700
|
|     update master commit
|
* commit c08d1c1d30f56b5b1ac851ec34e90ca01084a665
  Author: myPar <andrebobrovs@mail.ru>
  Date:   Sat Feb 25 11:25:19 2023 +0700

      "initial commit to master"

```
У ветки feature branch 3 простых коммита поверх master. Объединим их в один:  

``` bash
$ git rebase -i @~3
```

В редакторе открывается файл редактирования. Коммиты перебазируются в порядке, в котором они указаны в это файле. Рассмотрим опции редактирования:  

``` bash
p - pick: берём коммит без изменений
r - reword: берём коммит с редактированием его сообщения
d - drop: удаляем коммит
e - edit: останавливаемся и редактируем изменения
s - squash: объединяем коммит с предыдущим
f - fixup: 
```
Произведение указанных в файле изменений будет осуществляться последовательно в процессе работы rebase.  
### SSH ключи

GitHub аккаунт должен удостовериться, что устройство, с которого происходит работа пренадлежит владельцу репозитория, или однуму из разработчиков. Один из способов это сделать - сгенерировать ssh-ключ и доступаться к удалённому репозиторию через ssh-протокол.  

При генерации ключа можно добавить к нему пароль, тогда его ввод будет требоваться каждый раз, когда этот ключ будет использоваться. Таким образом, человек с другого устройства, даже если по какой-то причине будет обладать ssh-ключём всё равно не сможет его использовать без знания пароля. Ну а чтобы вам не вводить пароль каждый раз, можно добавить ключ к ssh-агенту. Вся эта процедура описана ниже:  

1. Открываем Git Bash
2. Вводим строку:
``` bash
$ ssh-keygen -t ed25519 -C "your_email@example.com"
```

Эта команда сгенерирует пару ssh-ключей: публичный и приватный. Публичный ключ будет сохранён с расширением __.pub__, а приватный без какого либо расширения:
``` bash
> Generating public/private ed25519 key pair.
> Enter file in which to save the key (/c/Users/Andrey/.ssh/id_ed25519):
```
3. Далее вводим путь до файла, куда ключ будет сохранён. Если нажать Enter, то будет 
установлен путь по умолчанию.  

4. Далее вводим пароль:
``` bash
> Enter passphrase (empty for no passphrase): [Type a passphrase]
> Enter same passphrase again: [Type passphrase again]
```

Приватный ключ является идентифицирующим для вашего устройства, им нельзя делиться ни с кем. Публичный ключ вы копируете в GitHub аккаунт. Теперь любые операции с GitHub аккаунтом с вашего устройства будут верефицироваться через ssh-ключи. Понятно, что в таком случае используется ssh-протокол вместо http.  